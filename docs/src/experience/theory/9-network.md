---
title: 网络协议
description: 网络协议
---

# 网络协议面试题

## TCP中三次握手和四次挥手

* **TCP 三次握手**

  TCP 协议中三次握手用于建立一个可靠的连接。具体步骤如下：

  1. **SYN**：客户端向服务端发送一个 SYN（同步序列编号）包，表示客户端希望建立连接，并告知服务端初始序列号（Sequence Number）。

  2. **SYN-ACK**：服务器收到 SYN 包后，响应一个包含 SYN 和 ACK（确认）标志的包，表示同意建立连接，并向客户端发送服务器的初始序列号。

  3. **ACK**：客户端收到 SYN-ACK 包后，发送一个 ACK 包，确认已收到服务器的 SYN包。此时，三次握手完成，连接建立。

  在三次握手中，序列号的使用是为了确保每个数据包的唯一性和顺序性。

* **TCP 四次挥手**

  TCP 四次挥手用于终止连接。具体步骤如下：

  1. **FIN**：客户端发送一个 FIN（终止）包，表示它希望终止连接。

  2. **ACK**：服务器收到 FIN 包后，发送一个 ACK包，确认已收到终止请求。

  3. **FIN**：服务器也发送一个 FIN 包，表示它也希望终止连接。

  4. **ACK**：客户端收到服务器的 FIN 包后，发送一个 ACK 包，确认已收到服务器的终止请求。此时，连接正式关闭。

## HTTP/2 有哪些改进 <span style="padding: 2px 8px; background: #EC5975; color: #FFF; border-radius: 4px;">高频</span>

HTTP/2 在多个方面相较于 HTTP/1.1 进行了显著改进：

* **多路复用**

  HTTP/2 允许多个请求和响应通过单一的 TCP 连接并行进行，减少了连接建立的开销，并且避免了 HTTP/1.1 中的队头阻塞问题。

  **HTTP/2 多路复用的挑战**

  * **队头阻塞依然存在**

  * 如果底层 TCP 连接发生拥塞或丢包，所有流都会受到影响。
  * 解决方案：HTTP/3 引入了基于 UDP 的 QUIC 协议，完全消除 TCP 带来的队头阻塞问题。

* **头部压缩**

  HTTP/2 引入了 HPACK 算法，对 HTTP 头部进行高效压缩。这大大减少了在多次请求中传输相同头部数据的带宽占用，提升了传输效率。

* **服务器推送**

  HTTP/2 支持服务器在客户端请求之前主动推送资源。这意味着服务器可以在响应页面时，提前推送所需的 CSS、JavaScript 文件，从而减少延迟。

* **二进制分帧**

  HTTP/2 使用二进制格式传输数据，而不是文本格式。二进制格式更高效，容易解析和处理，同时也更适合多路复用的需求。

* **流量控制**

  HTTP/2 允许客户端和服务器对数据流进行优先级排序和流量控制，从而更好地管理资源和带宽，避免资源竞争导致的性能下降。

这些改进使得 HTTP/2 在处理高延迟、高带宽网络环境时，性能提升尤为明显，特别是在移动网络和 CDN 环境下。HTTP/2 的设计目的就是为了适应现代网络应用的需求，提供更快、更可靠的网页加载体验

## 帧是如何标记属于哪个流的

在 HTTP/2 中，每个帧都会有一个包含流标识符的字段，用于标记该帧属于哪个流。这些帧在同一个连接中传输，并通过流标识符区分它们的归属。具体来说，每个帧头部包含一个 31 位的流标识符字段，该字段标识了该帧所属的流。流标识符为 0 的帧是保留给特定用途的控制帧。

## HTTP/3的特性

HTTP/3 是基于 QUIC（Quick UDP Internet Connections）协议的全新 HTTP 协议版本，它的主要特性包括以下几点：

* **基于 QUIC 协议**

  HTTP/3 不再使用传统的 TCP，而是基于 QUIC 协议，QUIC 是一个基于 UDP 的协议，专为减少连接建立时间和提高传输效率而设计。它集成了加密、可靠性和多路复用等特性。

* **零连接延迟（Zero Round Trip Time, 0-RTT）**

  通过 QUIC 协议，HTTP/3 可以实现 0-RTT 连接建立。这意味着在第一次连接后，后续请求可以无需等待完整的握手过程，从而大大减少了连接建立的延迟。

* **多路复用**

  HTTP/3 在一个连接中支持多个流的并行传输。这与 HTTP/2 的多路复用相似，但因为基于 QUIC，HTTP/3 避免了 TCP 队头阻塞（Head-of-line blocking）的问题。

* **加密和安全性**

  HTTP/3 默认启用 TLS 1.3 加密，提供更强的安全性和隐私保护。QUIC 协议本身将加密集成在协议层面，避免了单独的 TLS 握手。

* **减少队头阻塞**

  由于 QUIC 协议允许多条流并行传输，即使其中一条流发生丢包，也不会影响其他流的传输。这与 HTTP/2 基于 TCP 的传输不同，后者会受到队头阻塞的影响。

* **改进的拥塞控制**

  QUIC 提供了改进的拥塞控制机制，能够更高效地应对网络波动，提高数据传输的稳定性和性能。

## TCP 和 UDP 的区别

| 特性 | TCP | UDP |
| --- | --- | --- |
| 连接类型 | 面向连接 | 面向无连接 |
| 传输可靠性 | 可靠，提供重传、校验等机制 | 不可靠，可能丢包或乱序 |
| 数据顺序 | 保证按序到达 | 不保证 |
| 速度 | 较慢（连接、校验等增加延迟） | 较快（无连接、校验过程） |
| 头部开销 | 较大（20 字节以上） | 较小（8 字节） |
| 流量控制 | 有 | 无 |
| 适用场景 | 高可靠性需求（如文件传输、浏览器） | 实时性需求（如视频通话、直播） |

## OSI 七层模型

| 层次 | 名称 | 主要功能 | 相关协议/技术 |
| --- | --- | --- | --- |
| 7 | 应用层 （Application） | 为应用程序提供网络服务的接口，直接面向用户。 | HTTP, FTP, SMTP, DNS |
| 6 | 表示层 （Presentation） | 数据的格式化、加密/解密、压缩/解压缩，保证数据可理解性。 | JPEG, MPEG, TLS/SSL |
| 5 | 会话层 （Session） | 管理通信会话，负责建立、维护和终止会话。 | PPTP, NetBIOS |
| 4 | 传输层 （Transport） | 提供端到端的传输服务，包括错误检测、数据分段和重传。 | TCP, UDP |
| 3 | 网络层 （Network） | 负责路由选择和逻辑地址管理，确定数据包的传输路径。 | IP, ICMP, ARP, OSPF |
| 2 | 数据链路层 （Data Link） | 处理网络节点之间的数据传输，提供物理地址（MAC 地址）。 | Ethernet, PPP, Frame Relay |
| 1 | 物理层 （Physical） | 定义物理设备的接口标准、信号传输方式（电信号、光信号等）。 | 光纤、网线、USB，IEEE 802.3 |

## 如果A 与 B 建立了正常连接后，从未相互发过数据，这个时候 B 突然机器重启，问 A 此时处于 TCP 什么状态？如何消除服务器程序中的这个状态？

在A和B建立正常连接后，如果B突然重启而从未相互传输数据，此时A的TCP连接状态会保持不变，处于 `ESTABLISHED` 状态。A的操作系统不会立即知道B已经重启，因为没有任何数据传输来触发连接状态的改变。通常，A需要通过发送或接收数据来检测到连接异常。

为了消除服务器程序中的这种状态，可以采取以下方法：

* **设置`SO_KEEPALIVE`选项**

  通过setsockopt函数开启TCP连接的Keep-Alive功能，这样可以定期发送Keep-Alive探测包来检测对方是否仍然在线。不过默认的Keep-Alive时间间隔可能较长，可以根据需要调整。

* **使用非阻塞模式和`select()`函数**

  将socket设置为非阻塞模式，并使用select()或poll()来监控socket的可读性或可写性，可以设定超时时间来避免长时间等待。

* **检测发送错误**

  当对端重启时，发送数据通常会导致发送错误，应用程序可以根据发送操作的返回值来判断并处理连接断开。

  当看到连接状态为 `ESTABLISHED`，开发者可以确信两端已经建立了可靠的连接，并可以开始数据传输。

## 介绍 HTTPS 握手过程 <span style="padding: 2px 8px; background: #EC5975; color: #FFF; border-radius: 4px;">高频</span>

1. 客户端使用 https 的 url 访问 web 服务器,要求与服务器建立 ssl 连接
2. web 服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端
3. 客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥
4. 客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥
5. 之后服务器与客户端使用秘钥加密传输

至此整个握手阶段结束。接下来，客户端与服务器进入加密通信。

## HTTPS 握手过程中，客户端如何验证证书的合法性 <span style="padding: 2px 8px; background: #EC5975; color: #FFF; border-radius: 4px;">高频</span>

1. **接收证书**

  当客户端向服务器发起 HTTPS 连接时，服务器会发送其数字证书。这个证书包含服务器的公钥以及由认证机构（CA）签名的数字签名。

2. **验证签名**

  客户端检查证书的签名是否由其信任的 CA 签发。每个浏览器都有一个预装的受信任 CA 列表。客户端使用 CA 的公钥解密证书的签名，并与证书内容进行比较，确保签名有效。如果签名无效，则表示证书可能被篡改，连接会被中断​。

3. **检查证书链**

  客户端会从服务器证书开始，一直追溯到根证书，确保每个中间证书都是由上一级 CA 签发的，直到找到受信任的根证书。这就是所谓的“信任链”验证。如果信任链中任何一个证书无效，整个验证过程都会失败。

4. **验证其他信息**

  客户端还会检查证书的有效期，确保证书在当前日期内有效。同时，客户端会验证证书中的域名与用户请求的域名匹配。如果域名不匹配，验证也会失败。

5. **处理自签名证书**

  如果服务器使用的是自签名证书，客户端通常会发出警告，提示用户手动决定是否信任该证书。这种情况下，用户需要验证证书指纹，以确保证书不是中间人攻击的结果。

## HTTP状态码

HTTP状态码是一组标准化的代码，用于描述HTTP请求的结果。它们被分为五类，每一类都表示一类特定的响应：

* **1xx (信息响应)**

  表示请求已被接收，继续处理。

  * 100 Continue：客户端应该继续发送请求的剩余部分。

* **2xx (成功响应)**

  表示请求已成功接收、理解并被处理。

  * 200 OK：请求成功，服务器返回请求的资源。
  * 204 No Content：请求成功，但没有返回任何内容。

* **3xx (重定向响应)**

  表示请求需要进一步操作才能完成。

  * 301 Moved Permanently：请求的资源已被永久移动到新位置。
  * 302 Found：请求的资源临时位于不同位置。

* **4xx (客户端错误响应)**

  表示请求包含错误或无法被服务器处理。

  * 400 Bad Request：请求有语法错误或无效参数。
  * 401 Unauthorized：请求未授权，需要身份验证。
  * 403 Forbidden：服务器理解请求但拒绝执行。
  * 404 Not Found：请求的资源在服务器上未找到。

* **5xx (服务器错误响应)**

  表示服务器未能执行有效请求。

  * 500 Internal Server Error：服务器遇到错误，无法完成请求。
  * 502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效响应。
  * 503 Service Unavailable：服务器暂时无法处理请求，通常由于超载或维护。
  * 504 Gateway Timeout：网关超时。当一个服务器（通常是代理或网关）在作为中间层时，等待上游服务器（如数据库服务器、API 服务器）响应请求时发生超时，这时会返回 504 错误。

## GET 和 POST 区别

* **语义和用途**

  * GET 请求用于从服务器获取资源或数据。它是一种“安全”的方法，不会对服务器上的数据造成任何改变。
  * POST 请求用于向服务器发送数据以进行处理，通常会引起服务器上数据的更改。例如，提交表单、上传文件等操作都是通过 POST 请求完成的。

* **参数传递方式**

  * 在 GET 请求中，参数会附加在 URL 的末尾，这意味着 URL 有长度限制，且参数在浏览器的地址栏中可见。
  * POST 请求则通过请求体传递数据，不受 URL 长度限制，且参数对用户不可见，更适合传递敏感信息。

* **缓存和书签**

  * GET 请求的结果通常是可以缓存的，并且可以被书签保存。当多次发送相同的 GET 请求时，理论上会返回相同的结果（即幂等性）。
  * POST 请求通常不会被缓存，且不能作为书签保存。因为 POST 请求可能会对数据进行修改，因此每次请求的结果可能不同。

* **幂等性**

  * GET 请求是幂等的，即多次执行相同的 GET 请求不会对服务器上的资源产生副作用。
  * POST 请求则不具备幂等性，多次执行可能会导致服务器上的资源发生多次变化。

* **安全性**

  * 虽然 POST 请求相比 GET 更适合传递敏感数据，但这并不意味着它更安全。实际上，无论是 GET 还是 POST，数据都可以被拦截或篡改，因此对于敏感信息传输，需要使用 HTTPS 协议来确保安全。

## 跨域

跨域问题是指浏览器出于安全原因限制一个网页上的脚本与另一个域上的资源进行交互。例如，当一个网页尝试从不同的域名、协议或端口的服务器获取数据时，就会遇到跨域问题。

**跨域问题的解决方法：**

* 1、**CORS（跨域资源共享）**： 这是最常用的方法。CORS 是一种机制，允许服务器在响应头中指定允许哪些源（域名、协议或端口）访问资源。服务器在响应头中添加 Access-Control-Allow-Origin 来指定允许的来源。可以通过以下方式设置 CORS：

```js
// Node.js Express 示例
const express = require('express');
const app = express();

app.use((req, res, next) => {
  res.header("Access-Control-Allow-Origin", "*"); // 允许所有域名访问
  res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
  next();
});

```

* 2、**JSONP（JSON with Padding）**： JSONP 是一种旧的解决跨域问题的方法，通过在客户端创建一个 `<script>` 标签，并将其 src 属性指向跨域的资源URL，利用 `<script>` 标签不受同源策略限制的特性来实现跨域请求。由于安全性和功能性原因，JSONP 不再推荐使用。

* 3、**服务器代理**： 在同源的服务器上设置一个代理，通过这个代理将请求转发到不同的服务器。这样，客户端只需向同源服务器发起请求，从而避开了跨域限制。

```js
// Node.js Express 示例
const express = require('express');
const request = require('request');
const app = express();

app.get('/api/*', (req, res) => {
  const url = 'http://other-domain.com' + req.url;
  req.pipe(request(url)).pipe(res);
});
```

* 4、**CSP（内容安全策略）**： 内容安全策略是一种防止跨站点脚本攻击的安全机制，它允许开发者定义哪些资源可以被加载。虽然 CSP 不是直接解决跨域问题的工具，但它可以增强应用的安全性。

## OPTIONS 请求的作用

OPTIONS 请求是一种 HTTP 方法，通常用于在发起实际请求之前获取服务器支持的请求方法和其他信息。它用于预检请求（preflight request），在进行跨域请求时，浏览器会先发送一个 OPTIONS 请求来询问服务器是否允许实际的跨域请求。

预检请求的主要作用包括：

* **检查服务器支持的方法**： 确认服务器是否允许使用特定的 HTTP 方法（如 POST、PUT 等）。

* **检查请求头**： 确认服务器是否允许特定的请求头字段（如 X-Custom-Header）。

* **检查请求源**： 确认服务器是否允许指定源的跨域请求。

预检请求通过设置 Access-Control-Allow-Methods 和 Access-Control-Allow-Headers 等响应头来告知浏览器服务器所支持的请求方法和请求头字段。

```shell
# OPTIONS 请求
OPTIONS /api/resource HTTP/1.1
Host: example.com
Origin: http://another-domain.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-Custom-Header

# 服务器响应
HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
```
