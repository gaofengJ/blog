---
title: 浏览器
description: 浏览器
---

# 浏览器 面试题

## 浏览器缓存读取规则

详见 [浏览器缓存](../../summary-primary/browser/cache.md)

## Cookie、Session、Token

* **Cookie：**

  * 定义：Cookie 是存储在用户浏览器中的小数据片段，通常用于保存用户的会话信息、用户偏好或跟踪用户行为。

  * 特点：
    * Cookie 会随每个请求发送到服务器，因此可能带来性能开销。
    * 可以设置过期时间，持久化存储。
    * 安全性较低，如果不设置为 HttpOnly 和 Secure，容易被脚本攻击或在不安全连接中泄露。

* **Session：**

  * 定义：Session 是服务器端保存的用户会话数据，用于跟踪用户状态。客户端通常只保存一个Session ID（通过Cookie或URL传递）。

  * 特点：
    * Session 数据存储在服务器端(可以存在内存里/redis/数据库)，相对更安全，但增加了服务器的存储和处理负担。
    * 通过 Session ID 可以在服务器端检索到对应的会话数据。
    * 适用于需要短期存储用户状态的情况。

* **Token：**

  * 定义：Token 是一种更现代的身份验证机制，通常用于无状态认证。Token 包含所有认证信息（如 JWT），由服务器签名并发给客户端。

  * 特点：
    * 无需在服务器端保存用户状态，适合分布式系统。
    * 通常使用 Access Token（短期）和 Refresh Token（长期）组合来进行认证。
    * 客户端可以将 Token 存储在 localStorage、sessionStorage 或 cookie 中，但安全性要求较高，特别是在浏览器环境中，建议使用 HttpOnly 的 Cookie 存储 Token。

## JWT 是什么

JWT (JSON Web Token) 是一种开放标准（RFC 7519），用于在各方之间作为 JSON 对象安全地传输信息。它的常见用途是身份验证和信息交换。以下是它的主要特点和工作原理：

* 结构：JWT 由三部分组成，分别用点分隔：

  * **Header**：包含签名算法的信息（例如 HMAC、SHA256）。
  * **Payload**：存储声明（claims），即要传递的数据，通常是用户信息。
  * **Signature**：由 Header、Payload 和密钥计算生成，用于验证数据的完整性。

* 使用场景：

  * **身份验证**：用户登录后，服务器生成一个 JWT 并发送给客户端。客户端将此 JWT 存储（如 LocalStorage 或 HttpOnly Cookie），并在每次请求时附加到请求头中。
  * **信息交换**：由于 JWT 是签名的，它可以确保信息的真实性与未被篡改。

* 优点：

  * **轻量化**：无需在服务器端保存会话状态。
  * **自包含性**：所有必要信息都包含在令牌中。
  * **跨域支持**：特别适用于微服务架构。
* 缺点：

  * **长度较大**：可能导致额外的带宽消耗。
  * **无法撤销**：一旦签发，令牌在有效期内无法强制失效。

## localStorage 和 sessionStorage

localStorage 和 sessionStorage 都是 HTML5 提供的 Web 存储 API，用于在客户端保存数据。它们的主要区别在于数据的生命周期和作用域：

* **数据存储期限**

  * localStorage: 数据会一直保存在浏览器中，直到被手动删除，即使浏览器关闭后数据也会保留。适合保存长期有效的数据。
  * sessionStorage: 数据仅在当前会话（浏览器窗口或标签页）期间有效。一旦关闭窗口或标签页，数据就会被清除。适合保存仅在当前会话有效的数据。

* **作用域**

  * localStorage: 在同一域名下的所有页面之间共享数据，即使是不同的窗口或标签页也可以访问相同的数据。
  * sessionStorage: 仅在同一窗口或标签页的不同页面之间共享数据，不同窗口或标签页之间的数据互不影响。

* **数据容量**

  * localStorage 和 sessionStorage 的容量通常都为 5MB，但具体大小可能会因浏览器而异。

* **用法场景**

  * localStorage: 适用于需要持久保存的用户设置、用户数据等。
  * sessionStorage: 适用于保存临时数据，如表单输入、用户操作的暂存数据等。

## 浏览器垃圾回收机制

浏览器的垃圾回收机制是管理内存的重要功能，负责自动清理不再需要的对象以释放内存资源。大多数现代浏览器使用的是“标记-清除”（Mark-and-Sweep）算法。

标记-清除算法的基本工作流程如下：

1. **标记阶段**

  垃圾收集器从一组根对象开始（例如全局对象、局部变量等），遍历所有能够访问的对象，并标记它们为“可达”。

2. **清除阶段**

  在标记完所有可达对象后，垃圾收集器会扫描内存，释放那些没有被标记为“可达”的对象，因为它们不再被任何其他对象引用。

此外，垃圾收集器还能处理循环引用的问题。例如，如果两个对象相互引用但没有其他对象引用它们，当这两个对象不再需要时，垃圾收集器仍然能够正确地清理它们。

浏览器间的差异：不同浏览器和JavaScript引擎可能会在垃圾收集的具体实现上有所差异，例如采用不同的优化策略或参考计数技术。

需要注意的是，如果垃圾收集不当，例如在 Internet Explorer 中，可能会出现内存泄漏的问题，这通常发生在 JavaScript 对象与DOM元素之间存在循环引用的情况下。

为了优化内存使用并减少内存泄漏，开发者可以遵循一些最佳实践，例如：尽量避免使用全局变量、及时清除事件监听器、使用 WeakMap 或 WeakSet 来存储临时对象等。
