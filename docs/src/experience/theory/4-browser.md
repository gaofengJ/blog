---
title: 浏览器
description: 浏览器
---

# 浏览器 面试题

## 从浏览器地址栏输入 url 到请求返回发生了什么 <span style="padding: 2px 8px; background: #EC5975; color: #FFF; border-radius: 4px;">高频</span>

1. **URL 解析**

浏览器首先分析你输入的 URL，识别出协议（如 HTTP 或 HTTPS）、域名（如 `www.example.com`）、端口号（默认为 80 或 443）和路径（如 `/index.html`）。这些信息用来决定如何访问服务器和请求哪些资源。

此过程中包含强缓存和协商缓存。

2. **DNS 解析**

浏览器需要将域名转换为 IP 地址，以便与服务器通信。浏览器会首先在本地缓存中查找是否有对应的 IP 地址记录。如果没有，浏览器会查询操作系统缓存、路由器缓存，最后查询 DNS 服务器​ (FreeCodeCamp)。

DNS 查询包括以下几个步骤：

* 浏览器检查本地缓存。
* 查询操作系统缓存。
* 向路由器发送请求以检查其缓存。
* 如果这些缓存中都没有结果，浏览器会向 ISP（互联网服务提供商）的 DNS 服务器发送查询。
* 如果 ISP 的 DNS 服务器无法解析，查询会被发送到更高层级的 DNS 服务器，直到找到负责该域名的权威 DNS 服务器，返回 IP 地址。

3. **建立 TCP 连接**

获得 IP 地址后，浏览器会与目标服务器建立 TCP 连接。这个过程称为“三次握手”：

* 浏览器发送一个 SYN（同步序列号）包到服务器，询问是否可以建立连接。
* 服务器返回一个 SYN-ACK（同步-确认）包，表示接受连接请求。
* 浏览器发送一个 ACK（确认）包确认，连接建立成功。

4. **发送 HTTP 请求**

TCP 连接建立后，浏览器会发送 HTTP 请求到服务器。请求通常是 GET 请求，用来请求特定的网页或资源。请求头包含了用户代理信息、支持的语言、已存储的 cookies，以及其他 HTTP 头信息。
例如，一个典型的 HTTP GET 请求可能看起来像这样：

```sh
GET /index.html HTTP/1.1
Host: <www.example.com>
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9
```

5. **服务器处理请求**

服务器接收到请求后，会根据请求的路径查找资源，生成响应，并发送回客户端。响应包含 HTTP 状态码（如 200 表示成功），响应头（如内容类型、内容长度等）和实际的 HTML 内容。
典型的 HTTP 响应可能如下所示：

```php
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 348
Date: Mon, 12 Aug 2024 12:28:53 GMT

<html>
<head><title>Example</title></head>
<body><h1>Hello, world!</h1></body>
</html>
```

6. **浏览器渲染页面**

浏览器接收到服务器响应后，会开始解析 HTML 文档，构建 DOM（文档对象模型）树和 CSSOM（CSS 对象模型）树，并执行 JavaScript。浏览器根据这些模型渲染页面，将内容显示给用户。

在渲染过程中，浏览器会根据 HTML 中的链接发送额外的 HTTP 请求，以获取嵌入的资源（如 CSS 文件、JavaScript 文件和图像等），并逐步构建和展示完整的网页。

7. **断开 TCP 连接**

TCP 四次挥手用于终止连接。具体步骤如下：

* 1、客户端发送一个 FIN（终止）包，表示它希望终止连接。

* 2、服务器收到 FIN 包后，发送一个 ACK包，确认已收到终止请求。

* 3、服务器也发送一个 FIN 包，表示它也希望终止连接。

* 4、客户端收到服务器的 FIN 包后，发送一个 ACK 包，确认已收到服务器的终止请求。此时，连接正式关闭。

8. **页面加载完成**

页面加载完成后，浏览器继续监视用户与页面的交互，如点击、滚动和输入事件，并根据需要发送新的请求以获取更多数据（如通过 AJAX 或 Fetch API）

## 介绍下重绘和回流（`Repaint` & `Reflow`），以及如何进行优化 <span style="padding: 2px 8px; background: #EC5975; color: #FFF; border-radius: 4px;">高频</span>

**重绘(Repaint)** 和 **回流(Reflow)** 是浏览器在渲染页面时的两个重要概念：

* **重绘**

  当元素的外观（例如颜色、背景、边框等）发生变化时需要进行重绘。重绘不会影响布局，所以相对回流来说开销较小。

* **回流**

  当页面的布局和几何属性（例如元素的大小、位置）发生变化时，浏览器需要重新计算元素的布局。这一过程称之为回流。回流是一个耗费资源的过程，因为它要求浏览器计算页面上所有被影响的部分。

### 优化策略

* **批量修改样式**

  尽量避免逐条修改样式，应该一次性更改多个样式。例如，使用class切换来替代多个单独的样式设置。

* **最小化布局触发**
  避免频繁读取会触发回流的属性，例如 offsetTop、scrollTop、getBoundingClientRect等。可以将这些操作集中在一次执行，避免重复触发回流。

* **使用文档片段（DocumentFragment）**

  在进行多次DOM操作时，可以使用DocumentFragment，将所有变更一次性添加到文档中，减少回流和重绘。

* **CSS 动画**

  尽量使用 transform 和 opacity 进行动画，这些属性只会触发重绘，而不会导致回流。

* **脱离文档流操作**

  对于需要频繁操作的元素，可以先将其从文档流中移除（例如，使用 `display: none;`），完成所有操作后再将其放回文档中。

## 页面卡顿可能有哪些原因

页面卡顿通常有以下几个原因：

* **重绘和重排（Repaint & Reflow）**

  当页面的DOM或CSS发生改变时，浏览器需要重新渲染页面。复杂的布局或者频繁的DOM修改（例如在滚动或输入时）可能会导致性能问题。重排尤其耗费性能，它会影响页面的布局和显示，因此频繁的DOM操作或CSS变更会导致页面卡顿。

* **JavaScript性能瓶颈**

  长时间运行的JavaScript代码会阻塞浏览器的UI线程，导致页面卡顿。例如，在事件处理函数中执行复杂的计算，或者处理大量数据时，JavaScript线程会占用过多时间，影响页面的响应速度。

* **内存泄漏**

  如果网页存在内存泄漏问题（比如没有清理掉不再使用的对象），会导致浏览器内存不断增加，最终影响页面流畅性。

* **图片和资源加载问题**

  未优化的图片、音视频文件、字体等资源加载较慢，会导致页面加载或滚动时出现卡顿。大文件的资源未进行懒加载或按需加载也会加剧卡顿现象。

* **第三方库或插件**

  一些外部库（如 jQuery 或第三方广告插件等）可能会导致性能问题，特别是当它们频繁操作DOM或进行复杂的计算时，会影响页面的流畅度。

* **CSS性能问题**

  使用复杂的CSS选择器或者CSS动画效果时，可能会对渲染性能产生负面影响。比如，使用大量的 box-shadow 、filter 等可能导致重排，影响性能。

为了避免这些问题，可以采取如下优化措施：减少 DOM 操作，合理使用 requestAnimationFrame 优化动画，避免长时间运行的 JavaScript 任务，优化图片资源和按需加载，清理无用的对象和事件监听器

## 内存泄漏的场景有哪些

在 JavaScript中，内存泄漏通常发生在我们意外地持有了对对象的引用，而忘记了释放它们。常见的内存泄漏场景包括：

* **未移除的事件监听器**

  如果事件监听器在不再需要时没有正确移除，它们会继续持有对 DOM 元素的引用，导致内存无法回收。例如，当你注册了一个事件监听器，但没有调用 removeEventListener 来解除绑定时，DOM元素和事件处理函数会一起保留在内存中​。

* **闭包导致的引用保持**

  当函数内部的局部变量被闭包引用时，如果这些闭包没有被正确清理，它们会继续占用内存。例如，在函数内部创建一个闭包，并且闭包中的某些变量不再被使用，但闭包仍然存在时，这些变量将无法被垃圾回收​。

* **全局变量**

  如果不小心将变量挂载到全局对象（例如 window ）上，这些变量即使在函数结束后也会持续存在，造成内存泄漏。避免使用全局变量，或者用 let 和 const 声明局部变量，有助于减少这种情况的发生。

* **DOM元素引用未清理**

  当通过 JavaScript 创建 DOM 元素，并且未正确删除或解除它们的引用时，它们会继续占用内存。这种泄漏通常发生在动态生成的元素没有在不需要时被清理或移除时​。

* **定时器和回调函数**

  定时器（如 setInterval ）或回调函数如果未被清理，也可能导致内存泄漏。确保调用 clearInterval 或 clearTimeout 来停止不再需要的定时器，以免继续占用内存。

通过遵循最佳实践，确保及时清理事件监听器、关闭定时器并避免不必要的全局变量引用，可以有效减少内存泄漏的风险。

## JavaScript的事件循环机制( EventLoop ) <span style="padding: 2px 8px; background: #EC5975; color: #FFF; border-radius: 4px;">高频</span>

首先明确几个概念：

### 任务队列

* js 分为同步任务和异步任务
* 同步任务都在主线程上执行，形成一个执行栈
* 主线程之外，事件触发线程负责管理所有任务队列，只要异步任务有了运行结果，就会在任务队列中放置一个事件
* 一旦执行栈中的所有同步任务执行完毕（此时 js 引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。

根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或多个任务队列（ task queue ），一个任务队列便是一系列有序任务（ task ）的集合；每个任务都有一个任务源（ task source ），源自同一个任务源的 task 必须放在同一个任务队列，从不同源来的则被添加到不同队列。setTimeout/Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。

> [!TIP]
>
> 任务队列的划分
>
> * 定时器任务队列（Timer Task Queue）：
> 由 setTimeout 和 setInterval 等定时器任务生成。
> * UI 渲染任务队列（Rendering Task Queue）：
> 浏览器用来执行与页面渲染相关的任务。
> * 用户交互任务队列（User Interaction Task Queue）：
> 包括点击、键盘事件等 DOM 事件任务。
> * 网络请求任务队列（Network Task Queue）：
> 例如 XMLHttpRequest 或 fetch 请求的回调。
> * 微任务队列（Micro Task Queue）：
> 专门存放微任务，比如 Promise.then、MutationObserver。

### 宏任务

macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。

浏览器为了能够使得 JS 内部 macrotask 与 DOM 任务能够有序的执行，会在一个 macrotask 执行结束后，在下一个 macrotask 执行开始前，对页面进行重新渲染。

macrotask 主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)

### 微任务

microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。

所以它的响应速度相比 setTimeout（ setTimeout 是 macrotask ）会更快，因为无需等渲染。也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）。

microtask主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)。

### 运行机制

在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：

* 执行一个宏任务（栈中没有就从事件队列中获取）
* 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
* 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
* 当前所有微任务执行完毕，开始检查渲染，然后GUI线程接管渲染
* 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

## 写出下面代码的运行结果

```js
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}
async function async2() {
  console.log('async2');
}
console.log('script start');
setTimeout(function() {
  console.log('setTimeout');
}, 0)
async1();
new Promise(function(resolve) {
  console.log('promise1');
  resolve();
}).then(function() {
  console.log('promise2');
});
console.log('script end');
```

```js
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```

### 执行过程

1. 首先，事件循环从宏任务（ macrotask ）队列开始，这个时候，宏任务队列中只有一个 script（整体代码）任务；当遇到任务源（ task source ）时，则会先分发任务到对应的任务队列中去。

2. 这段代码首先定义了两个 async 函数，然后执行了一个 console，直接输出 `script start`。之后 script 任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会将其任务分发到对应的队列中去。

3. script 任务继续往下，执行了 async1 函数，async 函数之前的代码是立即执行的，所以会立即输出 `async1 start`。

4. setTimeout 的回调是宏任务，会被加入到宏任务队列中去。

5. 遇到 await 时，会将 await 后面的表达式执行一遍，所以紧接着输出`async2`,然后将 await 后面的代码也就是 `console.log(async1 end)`加入到microtask 中的 Promise 队列中，接着跳出 async1 函数来执行后面的代码。

6. script 任务继续往下执行，遇到了 Promise 实例。由于 Promise 中的函数是立即执行的，而后续的 `.then` 则会被分发到 microtask 中的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 promise2 分配到对应队列。

7. script 任务继续往下，最后输出了 `script end`，至此全局任务就执行完毕了。

8. 执行完一个宏任务后，回去检查是否存在微任务。如果有，则执行微任务直至清空 Microtask queue。所以在 script 任务执行完毕后，开始查找清空微任务队列。此时，微任务中 Promise 队列有两个任务 async1 end 和 promise2，因此按照先后顺序输出`async1 end` 和 `promise2`。当所有 Microtasks 执行完毕后，表示第一轮的循环就结束了。

9. 第二轮循环依旧从宏任务队列开始。此时宏任务重只有一个 setTimeout，取出直接输出即可，至此整个流程结束。

## 浏览器和 Node 事件循环的区别

* **浏览器**

  关于微任务和宏任务在浏览器的执行顺序是这样的：

  * 执行一个macro-task（宏任务）
  * 执行完micro-task队列（微任务）

* **Node**

  Node的事件循环是libuv实现的。

  大体的task（宏任务）执行顺序是这样的：

    1. Timers 阶段：执行 setTimeout 和 setInterval 的回调函数。
    2. I/O 回调阶段：执行 I/O 相关的回调函数。
    3. Idle, Prepare 阶段：系统内部使用，几乎没有用户代码。
    4. Poll 阶段：执行新的 I/O 事件，或等待新的 I/O。
    5. Check 阶段：执行 setImmediate 的回调。
    6. Close 阶段：执行关闭事件的回调，比如 socket.on('close')。

  Node 10 以前：

  * 执行完一个阶段的所有任务
    * 在每个事件循环阶段（如 Timers 阶段、Poll 阶段等），会先执行该阶段的所有回调函数。
  * 执行完 nextTick 队列里面的内容
    * 在当前阶段的任务全部完成后，先清空 process.nextTick 队列。
    * 这会在任何微任务队列之前执行。
  * 然后执行完微任务队列的内容
    * 在清空 process.nextTick 队列后，执行微任务队列中的所有任务（比如 Promise 的 .then 回调）

  Node 11 以后和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列。

## 白屏时间和首屏时间

* **白屏时间 (White Screen Time)**

  * 定义：指用户打开网页后，在内容渲染出来之前看到的“空白屏幕”时间。也就是说，白屏时间是指页面开始加载到显示出任何可视内容之前的这段时间。
  * 衡量指标：白屏时间通常通过 First Paint (FP) 和 First Contentful Paint (FCP) 来衡量。

* **首屏时间 (First Screen Time)**

  * 定义：指用户访问网页后，浏览器渲染并显示出用户能够看到的第一屏内容的时间。首屏通常指页面中显示的第一部分，通常包括顶部的文字、图像、导航栏等，用户无需滚动就能看到的部分。
  * 衡量指标：首屏时间常通过 First Contentful Paint (FCP) 或 Largest Contentful Paint (LCP) 来衡量。

白屏时间和首屏时间通常会通过以下几个指标来衡量：

* **DNS 解析时间（ DNS Lookup Time ）**

  用户请求网页时，浏览器首先需要解析域名为 IP 地址，这个过程的耗时也会影响白屏时间。如果 DNS 解析时间较长，页面加载的初期就可能出现延迟。

* **TCP 连接时间（ TCP Connect Time ）**

  这是浏览器与服务器建立 TCP 连接所需的时间。在这段时间内，页面仍然是空白的。

* **DOMContentLoaded 时间**

  DOMContentLoaded 是一个事件，它指示 HTML 文档已完全加载和解析，但样式表、图片等资源可能还在加载中。这个时间点通常标志着页面的核心内容已加载完毕，是衡量白屏时间的重要指标。

* **First Paint（ FP ）**

  First Paint 指的是浏览器首次渲染任何像素的时间。它代表浏览器开始绘制页面的时间点，通常会看到背景色、占位图等内容的呈现。FP越早，白屏时间越短。

* **First Contentful Paint（ FCP ）**

  FCP 是指浏览器首次渲染出文本、图像或其他内容的时间。它是在用户看到页面的第一个可视内容时触发的事件，通常比 DOMContentLoaded 更接近用户看到实际内容的时间。FCP 是衡量白屏时间的一个重要指标。

* **Largest Contentful Paint（ LCP ）**

  LCP 主要衡量加载过程中，页面中最大可见元素（通常是图片、视频或大文本）的渲染时间。LCP 是衡量页面加载性能的重要指标，它代表用户认为页面加载完成的时间点。

* **Time to Interactive（TTI）**

  TTI 表示页面成为完全可交互的时间。即，所有资源加载完毕，事件处理器已经准备好，用户可以开始与页面进行交互。TTI 也是衡量白屏时间的一个重要指标。

* **Total Blocking Time（TBT）**

  TBT 衡量的是页面加载过程中，长时间阻塞主线程的时间。阻塞主线程的任务会导致用户无法与页面交互，因此 TBT 较长时，白屏时间可能会较长。

## CDN

内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。

**CDN原理：**

**当用户访问一个网站时，如果没有 CDN，过程是这样的：**

1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。

2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址。

3. 本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源

**如果用户访问的网站部署了 CDN，过程是这样的：**

1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。

2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。

3. 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。

4. 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。

5. SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。

6. 浏览器再根据 SLB 发回的地址重定向到缓存服务器。

7. 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。

## 回源

**回源** 是在内容分发网络（CDN）或缓存系统中常见的概念，指的是当请求的资源在 CDN 节点或缓存中未命中（即缓存中没有目标资源），需要向原始服务器（源站）请求资源的过程。

## 浏览器缓存读取规则 <span style="padding: 2px 8px; background: #EC5975; color: #FFF; border-radius: 4px;">高频</span>

详见 [浏览器缓存](../../summary-primary/browser/cache.md)

## Cookie、Session、Token

* **Cookie：**

  * 定义：Cookie 是存储在用户浏览器中的小数据片段，通常用于保存用户的会话信息、用户偏好或跟踪用户行为。

  * 特点：
    * Cookie 会随每个请求发送到服务器，因此可能带来性能开销。
    * 可以设置过期时间，持久化存储。
    * 安全性较低，如果不设置为 HttpOnly 和 Secure，容易被脚本攻击或在不安全连接中泄露。

* **Session：**

  * 定义：Session 是服务器端保存的用户会话数据，用于跟踪用户状态。客户端通常只保存一个Session ID（通过Cookie或URL传递）。

  * 特点：
    * Session 数据存储在服务器端(可以存在内存里/redis/数据库)，相对更安全，但增加了服务器的存储和处理负担。
    * 通过 Session ID 可以在服务器端检索到对应的会话数据。
    * 适用于需要短期存储用户状态的情况。

* **Token：**

  * 定义：Token 是一种更现代的身份验证机制，通常用于无状态认证。Token 包含所有认证信息（如 JWT），由服务器签名并发给客户端。

  * 特点：
    * 无需在服务器端保存用户状态，适合分布式系统。
    * 通常使用 Access Token（短期）和 Refresh Token（长期）组合来进行认证。
    * 客户端可以将 Token 存储在 localStorage、sessionStorage 或 cookie 中，但安全性要求较高，特别是在浏览器环境中，建议使用 HttpOnly 的 Cookie 存储 Token。

| 特性 | Access Token | Refresh Token |
| --- | --- | --- |
| 用途 | 访问受保护资源 | 刷新 Access Token |
| 有效期 | 短期（几分钟到几小时） | 长期（几天到几周） |
| 泄露后果 | 攻击者可访问资源，但时效有限 | 攻击者可长期刷新 Access Token |
| 存储方式 | 浏览器内存/前端存储 | HttpOnly Cookie 更安全 |
| 安全性 | 较高 | 高，需要严格保护 |

## JWT 是什么

JWT (JSON Web Token) 是一种开放标准（RFC 7519），用于在各方之间作为 JSON 对象安全地传输信息。它的常见用途是身份验证和信息交换。以下是它的主要特点和工作原理：

* 结构：JWT 由三部分组成，分别用点分隔：

  * **Header**：包含签名算法的信息（例如 HMAC、SHA256）。
  * **Payload**：存储声明（claims），即要传递的数据，通常是用户信息。
  * **Signature**：由 Header、Payload 和密钥计算生成，用于验证数据的完整性。

* 使用场景：

  * **身份验证**：用户登录后，服务器生成一个 JWT 并发送给客户端。客户端将此 JWT 存储（如 LocalStorage 或 HttpOnly Cookie），并在每次请求时附加到请求头中。
  * **信息交换**：由于 JWT 是签名的，它可以确保信息的真实性与未被篡改。

* 优点：

  * **轻量化**：无需在服务器端保存会话状态。
  * **自包含性**：所有必要信息都包含在令牌中。
  * **跨域支持**：特别适用于微服务架构。
* 缺点：

  * **长度较大**：可能导致额外的带宽消耗。
  * **无法撤销**：一旦签发，令牌在有效期内无法强制失效。

## localStorage 和 sessionStorage

localStorage 和 sessionStorage 都是 HTML5 提供的 Web 存储 API，用于在客户端保存数据。它们的主要区别在于数据的生命周期和作用域：

* **数据存储期限**

  * localStorage: 数据会一直保存在浏览器中，直到被手动删除，即使浏览器关闭后数据也会保留。适合保存长期有效的数据。
  * sessionStorage: 数据仅在当前会话（浏览器窗口或标签页）期间有效。一旦关闭窗口或标签页，数据就会被清除。适合保存仅在当前会话有效的数据。

* **作用域**

  * localStorage: 在同一域名下的所有页面之间共享数据，即使是不同的窗口或标签页也可以访问相同的数据。
  * sessionStorage: 仅在同一窗口或标签页的不同页面之间共享数据，不同窗口或标签页之间的数据互不影响。

* **数据容量**

  * localStorage 和 sessionStorage 的容量通常都为 5MB，但具体大小可能会因浏览器而异。

* **用法场景**

  * localStorage: 适用于需要持久保存的用户设置、用户数据等。
  * sessionStorage: 适用于保存临时数据，如表单输入、用户操作的暂存数据等。

## 浏览器垃圾回收机制

浏览器的垃圾回收机制是管理内存的重要功能，负责自动清理不再需要的对象以释放内存资源。大多数现代浏览器使用的是“标记-清除”（Mark-and-Sweep）算法。

标记-清除算法的基本工作流程如下：

1. **标记阶段**

  垃圾收集器从一组根对象开始（例如全局对象、局部变量等），遍历所有能够访问的对象，并标记它们为“可达”。

2. **清除阶段**

  在标记完所有可达对象后，垃圾收集器会扫描内存，释放那些没有被标记为“可达”的对象，因为它们不再被任何其他对象引用。

此外，垃圾收集器还能处理循环引用的问题。例如，如果两个对象相互引用但没有其他对象引用它们，当这两个对象不再需要时，垃圾收集器仍然能够正确地清理它们。

浏览器间的差异：不同浏览器和JavaScript引擎可能会在垃圾收集的具体实现上有所差异，例如采用不同的优化策略或参考计数技术。

需要注意的是，如果垃圾收集不当，例如在 Internet Explorer 中，可能会出现内存泄漏的问题，这通常发生在 JavaScript 对象与DOM元素之间存在循环引用的情况下。

为了优化内存使用并减少内存泄漏，开发者可以遵循一些最佳实践，例如：尽量避免使用全局变量、及时清除事件监听器、使用 WeakMap 或 WeakSet 来存储临时对象等。

## 进程和线程的区别

* 进程是操作系统中程序执行的基本单位，每个进程都是一个独立运行的程序实例。
* 线程是进程中的一个执行单元，是操作系统能够调度的最小单位。

JavaScript 在浏览器中运行在主线程上，负责处理 DOM 渲染、事件监听等任务。为避免主线程阻塞，浏览器使用 事件循环 和 任务队列 管理异步任务。
