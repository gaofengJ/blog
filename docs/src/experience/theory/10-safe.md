---
title: 安全
description: 安全
---

# 安全面试题

## cookie和token的区别

Cookie和Token是两种不同的认证和会话管理机制，以下是它们的主要区别：

* 存储位置：

  * Cookie：由服务器生成并存储在客户端浏览器中，每次请求都会自动包含在HTTP请求头中。
  * Token：通常存储在客户端的本地存储或会话存储中，需要手动包含在请求头中。

* 使用方式：

  * Cookie：用于传统的会话管理，服务器生成Session ID并通过Cookie发送给客户端，每次请求时浏览器会自动发送Cookie。
  * Token：通常为JWT（JSON Web Token），是一种自包含的、携带认证信息的字符串，客户端需要在每次请求中手动添加Token到请求头中。

* 安全性：

  * Cookie：容易受到CSRF（跨站请求伪造）攻击，因为浏览器会自动发送Cookie。可以通过设置HttpOnly标志减少XSS（跨站脚本）攻击的风险。
  * Token：因为浏览器不会自动发送Token，可以减少CSRF攻击的风险。Token通常是签名的，确保数据的完整性和真实性。

* 扩展性和标准化：

  * Cookie：基于RFC 6265标准，广泛支持并经过充分测试。
  * Token：如JWT，基于RFC 7519标准，可以跨多种系统和服务使用，具有更高的灵活性和可扩展性。

* 服务器端状态：

  * Cookie：服务器需要保存Session数据，与Session ID对应，增加了服务器的存储和管理负担。
  * Token：服务器不需要保存会话数据，所有信息都包含在Token中，便于水平扩展。

## 如何实现 token 加密

JWT 举例

* 需要一个secret（随机数）

* 后端利用secret和加密算法(如：HMAC-SHA256)对payload(如账号密码)生成一个字符串(token)，返回前端

* 前端每次request在header中带上token

* 后端用同样的算法解密

## 介绍下 HTTPS 中间人攻击

https协议由 http + ssl 协议构成。

中间人攻击过程如下：

* 服务器向客户端发送公钥

* 攻击者截获公钥，保留在自己手上

* 然后攻击者自己生成一个【伪造的】公钥，发给客户端

* 客户端收到伪造的公钥后，生成加密hash值发给服务器

* 攻击者获得加密hash值，用自己的私钥解密获得真秘钥

* 同时生成假的加密hash值，发给服务器

* 服务器用私钥解密获得假秘钥

* 服务器用加秘钥加密传输信息

防范方法：

* 客户端必须严格验证服务器的证书，确认其来自可信的证书颁发机构（CA）。

* 使用强制HTTPS策略（HSTS）确保所有通信都通过HTTPS进行，并防止降级攻击。

* 定期更新和检查浏览器中的根证书，确保没有被不可信的证书颁发机构滥用。

## 介绍下前端加密的常见场景和方法

在前端开发中，常见的加密场景和方法主要包括以下几种：

* 数据传输加密：前后端通信时，使用 HTTPS 是最基础的加密方法。它通过 SSL/TLS 协议确保数据在传输过程中的机密性和完整性。几乎所有的现代网络应用都应该使用 HTTPS 来保护数据传输​。

* 敏感数据加密：在前端存储或处理用户敏感信息时，可以使用如 CryptoJS 或 Web Cryptography API 进行加密。这些库可以帮助你在客户端加密数据，例如加密用户输入的密码或其他敏感信息​。

* 密码处理：密码通常不直接存储，而是使用哈希算法（如 bcrypt）进行哈希处理。虽然哈希主要在服务器端进行，但也可以在前端进行哈希处理，然后将哈希值发送到服务器​。

* JSON Web Token (JWT) 签名：JWT 常用于前后端分离的认证场景。前端可以使用 JWT 进行数据签名，以确保数据在传输中的完整性。Web Cryptography API 可以生成密钥对，用于对 JWT 进行签名和验证​。

## XSS（跨站脚本攻击）

概念：
XSS（Cross-Site Scripting）是指攻击者通过在网页中注入恶意的脚本代码，通常是 JavaScript，使得浏览器执行这些脚本，进而进行攻击。XSS 攻击通常通过 输入字段 或 URL 参数 等方式注入恶意脚本，目标通常是用户浏览器，目的是窃取用户信息、伪造用户操作或传播恶意软件。

攻击类型：
存储型 XSS（Stored XSS）
攻击者将恶意脚本存储在服务器端的数据库、日志文件、评论区等地方。受害者访问这些内容时，恶意脚本被加载并执行，窃取用户数据或执行其他恶意操作。

示例：

```html
<script>alert('You have been hacked');</script>
```

反射型 XSS（Reflected XSS）
攻击者通过 URL 参数或表单提交将恶意脚本发送到服务器，服务器再将这些脚本反射回浏览器，执行脚本。当用户点击恶意链接或提交表单时，脚本被执行。

DOM-based XSS（基于 DOM 的 XSS）
攻击者通过操控页面上的 DOM 结构，使得恶意脚本被执行，通常是在页面客户端处理用户输入时发生。

危害：
窃取用户信息：如 Cookies、Session ID、登录凭证等。
劫持用户账户：通过盗取用户的身份信息进行未授权的操作。
传播恶意软件：通过执行恶意脚本来感染用户的计算机或设备。
防护方法：
输出编码：对用户输入进行适当的编码处理，避免浏览器将其解释为可执行的脚本。例如，使用 HTML 转义字符来代替 <、>、& 等字符。

输入验证：对用户输入的数据进行严格的验证，确保输入内容符合预期格式，避免恶意内容进入应用。

使用 CSP（内容安全策略）：通过 CSP 来限制浏览器加载和执行不受信任的脚本，减少 XSS 攻击的风险。

HttpOnly 和 Secure 标记：确保 Cookies 设置了 HttpOnly 和 Secure 标记，以防止通过 JavaScript 获取 Cookie 信息。

## CSRF（跨站请求伪造）

概念：
CSRF（Cross-Site Request Forgery）是指攻击者诱使已登录用户的浏览器发送伪造的请求，借此执行恶意操作。攻击者通过在受害者的浏览器中发起与受害者已经认证过的站点的请求，使得该请求带有受害者的认证信息（如 Cookie、Session 等）。由于浏览器会自动携带认证信息，服务器误以为是受害者的合法请求，从而执行不法操作。

攻击方式：
发送伪造的请求：攻击者利用社交工程手段，诱导用户访问恶意网站或点击恶意链接，发起带有攻击者想要执行操作的请求。
不需要用户交互：攻击者可以通过在受害者不知情的情况下，在页面中自动发送请求，执行对用户不利的操作，如转账、修改密码等。
危害：
未授权操作：攻击者可以在不经过用户同意的情况下，利用用户的身份执行恶意操作。
账户劫持：如果受害者具有管理员权限，攻击者可能会获得更高的权限。
资金转移和数据泄露：攻击者通过伪造请求，可以在用户不知情的情况下，转移资金或窃取数据。
防护方法：
使用 Anti-CSRF Token：生成一个唯一的 Token，在每次请求时都进行验证，确保请求是由合法用户发起的。

检查 Referer 和 Origin 头部：通过检查请求的 Referer 或 Origin 头部，确保请求来源是合法的。

使用 SameSite Cookies：将 Cookies 设置为 SameSite，这样浏览器就不会在跨站请求中发送该 Cookie，防止 CSRF 攻击。

双重身份验证：对于高风险操作，如转账、修改密码等，要求用户进行额外的身份验证。
