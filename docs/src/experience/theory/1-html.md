---
title: HTML
description: HTML
---

# HTML 面试题

## 从浏览器地址栏输入 url 到请求返回发生了什么

1. **URL 解析**

浏览器首先分析你输入的 URL，识别出协议（如 HTTP 或 HTTPS）、域名（如 `www.example.com`）、端口号（默认为 80 或 443）和路径（如 `/index.html`）。这些信息用来决定如何访问服务器和请求哪些资源。

此过程中包含强缓存和协商缓存。

2. **DNS 解析**

浏览器需要将域名转换为 IP 地址，以便与服务器通信。浏览器会首先在本地缓存中查找是否有对应的 IP 地址记录。如果没有，浏览器会查询操作系统缓存、路由器缓存，最后查询 DNS 服务器​ (FreeCodeCamp)。

DNS 查询包括以下几个步骤：

* 浏览器检查本地缓存。
* 查询操作系统缓存。
* 向路由器发送请求以检查其缓存。
* 如果这些缓存中都没有结果，浏览器会向 ISP（互联网服务提供商）的 DNS 服务器发送查询。
* 如果 ISP 的 DNS 服务器无法解析，查询会被发送到更高层级的 DNS 服务器，直到找到负责该域名的权威 DNS 服务器，返回 IP 地址。

3. **建立 TCP 连接**

获得 IP 地址后，浏览器会与目标服务器建立 TCP 连接。这个过程称为“三次握手”：

* 浏览器发送一个 SYN（同步序列号）包到服务器，询问是否可以建立连接。
* 服务器返回一个 SYN-ACK（同步-确认）包，表示接受连接请求。
* 浏览器发送一个 ACK（确认）包确认，连接建立成功。

4. **发送 HTTP 请求**

TCP 连接建立后，浏览器会发送 HTTP 请求到服务器。请求通常是 GET 请求，用来请求特定的网页或资源。请求头包含了用户代理信息、支持的语言、已存储的 cookies，以及其他 HTTP 头信息。
例如，一个典型的 HTTP GET 请求可能看起来像这样：

```sh
GET /index.html HTTP/1.1
Host: <www.example.com>
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9
```

5. **服务器处理请求**

服务器接收到请求后，会根据请求的路径查找资源，生成响应，并发送回客户端。响应包含 HTTP 状态码（如 200 表示成功），响应头（如内容类型、内容长度等）和实际的 HTML 内容。
典型的 HTTP 响应可能如下所示：

```php
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 348
Date: Mon, 12 Aug 2024 12:28:53 GMT

<html>
<head><title>Example</title></head>
<body><h1>Hello, world!</h1></body>
</html>
```

6. **浏览器渲染页面**

浏览器接收到服务器响应后，会开始解析 HTML 文档，构建 DOM（文档对象模型）树和 CSSOM（CSS 对象模型）树，并执行 JavaScript。浏览器根据这些模型渲染页面，将内容显示给用户。

在渲染过程中，浏览器会根据 HTML 中的链接发送额外的 HTTP 请求，以获取嵌入的资源（如 CSS 文件、JavaScript 文件和图像等），并逐步构建和展示完整的网页。

7. **断开 TCP 连接**

TCP 四次挥手用于终止连接。具体步骤如下：

* 1、客户端发送一个 FIN（终止）包，表示它希望终止连接。

* 2、服务器收到 FIN 包后，发送一个 ACK包，确认已收到终止请求。

* 3、服务器也发送一个 FIN 包，表示它也希望终止连接。

* 4、客户端收到服务器的 FIN 包后，发送一个 ACK 包，确认已收到服务器的终止请求。此时，连接正式关闭。

8. **页面加载完成**

页面加载完成后，浏览器继续监视用户与页面的交互，如点击、滚动和输入事件，并根据需要发送新的请求以获取更多数据（如通过 AJAX 或 Fetch API）

## 如何理解 HTML 语义化

HTML语义化是指在HTML中使用具有特定含义的标签，以便更好地描述内容。这不仅有助于浏览器理解页面结构，也提高了搜索引擎的索引效率和页面的可访问性。

语义化标签有助于清晰地表达网页的结构和内容。例如，`<header>`标签用于定义页面的头部，`<nav>` 用于导航菜单，`<article>` 用于独立的文章内容。使用这些标签可以使得网页更具可读性和维护性，并有助于搜索引擎优化（SEO）和辅助技术如屏幕阅读器更好地理解页面内容。

## script 标签中 defer 和 async 的区别

defer 和 async 都是用于控制 JavaScript 文件加载和执行方式的 `<script>` 标签属性，但它们的工作原理有所不同：

* **defer**

  * defer 属性会使脚本在后台加载，并在 HTML 文档完全解析后执行。在这期间，浏览器继续解析文档，而不会因为脚本而阻塞。
  * 使用 defer 的脚本按它们在文档中的出现顺序执行。这对于有依赖关系的脚本非常重要，确保脚本按正确顺序执行。
  * 适合需要 DOM 完成后才能执行的脚本。

* **async**

  * async 属性同样使脚本在后台加载，但一旦脚本加载完毕，立即执行，不会等待其他脚本或 DOM 解析完成。
  * 使用 async 的脚本是独立的，可能会以任何顺序执行，因此不适合互相依赖的脚本。
  * 适用于独立的第三方脚本，如分析工具、广告等，不影响页面的其他功能​。

## 什么是事件代理（事件委托）

事件委托是指将事件处理程序添加到父元素上，而不是直接为每个子元素添加事件监听器。这样，父元素可以监听到其子元素的事件，通过事件的冒泡机制来捕获子元素的事件。它的好处包括减少内存消耗，简化代码，尤其适用于动态生成的元素。

示例：

```html
<ul id="parent">
  <li>项 1</li>
  <li>项 2</li>
  <li>项 3</li>
</ul>

<script>
  document.getElementById('parent').addEventListener('click', function(event) {
    if (event.target.tagName === 'LI') {
      alert('点击了: ' + event.target.textContent);
    }
  });
</script>
```

## 捕获 & 冒泡

在HTML中，事件的捕获和冒泡是指事件传播的两个不同阶段。它们定义了事件在DOM树中传播的顺序，决定了事件处理程序是在哪个阶段被触发的。

**定义**

* **捕获（Capturing）**

  捕获阶段，事件从最外层的父元素开始传播，一直到目标元素。在这个阶段，父元素首先接收到事件，然后逐级向下传递到事件的目标元素。

* **冒泡（Bubbling）**

  冒泡阶段，事件从目标元素开始传播，逐级向上冒泡到父元素，直到最外层的祖先元素。通常我们处理事件时，事件会从目标元素“冒泡”到其父元素，祖父元素，依此类推。

**区别**

* 顺序

  * 捕获阶段：事件从根节点开始，一直到目标元素。
  * 冒泡阶段：事件从目标元素开始，向上传递到根节点。

* 默认行为：

  * 默认情况下，大多数事件是在冒泡阶段触发的。比如点击事件默认是冒泡的。
  * 捕获阶段通常不常用，除非明确通过addEventListener中的capture参数启用。

* 使用时机：

  * 捕获阶段适合在事件传播开始时就进行处理，通常用于需要提前拦截的场景。
  * 冒泡阶段适合在事件传播到目标元素之后进行处理，通常用于DOM事件委托。

## 介绍下重绘和回流（`Repaint` & `Reflow`），以及如何进行优化

**重绘(Repaint)** 和 **回流(Reflow)** 是浏览器在渲染页面时的两个重要概念：

* **重绘**

  当元素的外观（例如颜色、背景、边框等）发生变化时需要进行重绘。重绘不会影响布局，所以相对回流来说开销较小。

* **回流**

  当页面的布局和几何属性（例如元素的大小、位置）发生变化时，浏览器需要重新计算元素的布局。这一过程称之为回流。回流是一个耗费资源的过程，因为它要求浏览器计算页面上所有被影响的部分。

### 优化策略

* **批量修改样式**

  尽量避免逐条修改样式，应该一次性更改多个样式。例如，使用class切换来替代多个单独的样式设置。

* **最小化布局触发**
  避免频繁读取会触发回流的属性，例如 offsetTop、scrollTop、getBoundingClientRect等。可以将这些操作集中在一次执行，避免重复触发回流。

* **使用文档片段（DocumentFragment）**

  在进行多次DOM操作时，可以使用DocumentFragment，将所有变更一次性添加到文档中，减少回流和重绘。

* **CSS 动画**

  尽量使用 transform 和 opacity 进行动画，这些属性只会触发重绘，而不会导致回流。

* **脱离文档流操作**

  对于需要频繁操作的元素，可以先将其从文档流中移除（例如，使用 `display: none;`），完成所有操作后再将其放回文档中。

## 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片

使用 1x1 像素的透明 gif 图片来发送数据埋点请求有几个关键原因：

* **兼容性高**

  这种方法几乎在所有浏览器和设备上都能工作，即使用户禁用了 JavaScript 或者使用了阻止跟踪脚本的插件​。

* **轻量级**

  1x1 像素的图片大小非常小，几乎不会占用带宽，这使得它非常高效​。

* **跨域支持**

  浏览器通常允许 img 标签跨域，这意味着可以从不同的域加载 JavaScript，从而实现更灵活的跟踪​。

* **隐藏性强**

  透明的 1x1 像素图片几乎不可见，不会影响用户的浏览体验，同时能够悄无声息地收集数据​。

这种方法被广泛用于网页访问统计、广告效果监测以及电子邮件阅读率统计等场景。尽管现代浏览器和邮件客户端开始默认阻止图片加载以防止这种跟踪，但它仍然是一个常见且有效的解决方案。

## 已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改

```html
<img src="1.jpg" style="width:480px!important;”>
```

**Answer**

```html
<style>
img {
  max-width: 300px;
}
</style>

<img src="1.jpg" style="width:480px!important;”>
```

## input 搜索如何防抖，如何处理中文输入

### 防抖方案

```js
function debounce(fn, delay = 100) {
  // 通过闭包缓存一个定时器id
  let timer;
  return (...args) => {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}
```

### 中文输入处理

ElementUI 是通过 `compositionstart` & `compositionend` 做的中文输入处理。

```html
<input
  ref="input"
  @compositionstart="handleComposition"
  @compositionupdate="handleComposition"
  @compositionend="handleComposition"
>
```

这3个方法是原生的方法，这里简单介绍下，官方定义如下 compositionstart 事件触发于一段文字的输入之前（类似于 keydown 事件，但是该事件仅在若干可见字符的输入之前，而这些可见字符的输入可能需要一连串的键盘操作、语音识别或者点击输入法的备选词）

简单来说就是切换中文输入法时在打拼音时(此时 input 内还没有填入真正的内容)，会首先触发 compositionstart，然后每打一个拼音字母，触发 compositionupdate，最后将输入好的中文填入input中时触发 compositionend。触发 compositionstart时，文本框会填入 “虚拟文本”（待确认文本），同时触发 input 事件；在触发 compositionend 时，就是填入实际内容后（已确认文本）,所以这里如果不想触发 input 事件的话就得设置一个 bool 变量来控制。

## 页面卡顿可能有哪些原因

页面卡顿通常有以下几个原因：

* **重绘和重排（Repaint & Reflow）**

  当页面的DOM或CSS发生改变时，浏览器需要重新渲染页面。复杂的布局或者频繁的DOM修改（例如在滚动或输入时）可能会导致性能问题。重排尤其耗费性能，它会影响页面的布局和显示，因此频繁的DOM操作或CSS变更会导致页面卡顿。

* **JavaScript性能瓶颈**

  长时间运行的JavaScript代码会阻塞浏览器的UI线程，导致页面卡顿。例如，在事件处理函数中执行复杂的计算，或者处理大量数据时，JavaScript线程会占用过多时间，影响页面的响应速度。

* **内存泄漏**

  如果网页存在内存泄漏问题（比如没有清理掉不再使用的对象），会导致浏览器内存不断增加，最终影响页面流畅性。

* **图片和资源加载问题**

  未优化的图片、音视频文件、字体等资源加载较慢，会导致页面加载或滚动时出现卡顿。大文件的资源未进行懒加载或按需加载也会加剧卡顿现象。

* **第三方库或插件**

  一些外部库（如 jQuery 或第三方广告插件等）可能会导致性能问题，特别是当它们频繁操作DOM或进行复杂的计算时，会影响页面的流畅度。

* **CSS性能问题**

  使用复杂的CSS选择器或者CSS动画效果时，可能会对渲染性能产生负面影响。比如，使用大量的 box-shadow 、filter 等可能导致重排，影响性能。

为了避免这些问题，可以采取如下优化措施：减少 DOM 操作，合理使用 requestAnimationFrame 优化动画，避免长时间运行的 JavaScript 任务，优化图片资源和按需加载，清理无用的对象和事件监听器

## 内存泄漏的场景有哪些

在 JavaScript中，内存泄漏通常发生在我们意外地持有了对对象的引用，而忘记了释放它们。常见的内存泄漏场景包括：

* **未移除的事件监听器**

  如果事件监听器在不再需要时没有正确移除，它们会继续持有对 DOM 元素的引用，导致内存无法回收。例如，当你注册了一个事件监听器，但没有调用 removeEventListener 来解除绑定时，DOM元素和事件处理函数会一起保留在内存中​。

* **闭包导致的引用保持**

  当函数内部的局部变量被闭包引用时，如果这些闭包没有被正确清理，它们会继续占用内存。例如，在函数内部创建一个闭包，并且闭包中的某些变量不再被使用，但闭包仍然存在时，这些变量将无法被垃圾回收​。

* **全局变量**

  如果不小心将变量挂载到全局对象（例如 window ）上，这些变量即使在函数结束后也会持续存在，造成内存泄漏。避免使用全局变量，或者用 let 和 const 声明局部变量，有助于减少这种情况的发生。

* **DOM元素引用未清理**

  当通过 JavaScript 创建 DOM 元素，并且未正确删除或解除它们的引用时，它们会继续占用内存。这种泄漏通常发生在动态生成的元素没有在不需要时被清理或移除时​。

* **定时器和回调函数**

  定时器（如 setInterval ）或回调函数如果未被清理，也可能导致内存泄漏。确保调用 clearInterval 或 clearTimeout 来停止不再需要的定时器，以免继续占用内存。

通过遵循最佳实践，确保及时清理事件监听器、关闭定时器并避免不必要的全局变量引用，可以有效减少内存泄漏的风险。

## JavaScript的事件循环机制( EventLoop )

首先明确几个概念：

### 任务队列

* js 分为同步任务和异步任务
* 同步任务都在主线程上执行，形成一个执行栈
* 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就会在任务队列中放置一个事件
* 一旦执行栈中的所有同步任务执行完毕（此时 js 引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。

根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或多个任务队列（ task queue ），一个任务队列便是一系列有序任务（ task ）的集合；每个任务都有一个任务源（ task source ），源自同一个任务源的task必须放在同一个任务队列，从不同源来的则被添加到不同队列。setTimeout/Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。

### 宏任务

macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。

浏览器为了能够使得JS内部 macrotask 与 DOM 任务能够有序的执行，会在一个 macrotask 执行结束后，在下一个 macrotask 执行开始前，对页面进行重新渲染。

macrotask 主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)

### 微任务

microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。

所以它的响应速度相比 setTimeout（ setTimeout 是 macrotask ）会更快，因为无需等渲染。也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）。

microtask主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)。

### 运行机制

在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：

* 执行一个宏任务（栈中没有就从事件队列中获取）
* 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
* 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
* 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
* 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

## 写出下面代码的运行结果

```js
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}
async function async2() {
  console.log('async2');
}
console.log('script start');
setTimeout(function() {
  console.log('setTimeout');
}, 0)
async1();
new Promise(function(resolve) {
  console.log('promise1');
  resolve();
}).then(function() {
  console.log('promise2');
});
console.log('script end');
```

```js
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```

### 执行过程

1. 首先，事件循环从宏任务（ macrotask ）队列开始，这个时候，宏任务队列中只有一个 script（整体代码）任务；当遇到任务源（ task source ）时，则会先分发任务到对应的任务队列中去。

2. 这段代码首先定义了两个 async 函数，然后执行了一个 console，直接输出 `script start`。之后 script 任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会将其任务分发到对应的队列中去。

3. script 任务继续往下，执行了 async1 函数，async 函数之前的代码是立即执行的，所以会立即输出 `async1 start`。

4. 遇到 await 时，会将 await 后面的表达式执行一遍，所以紧接着输出`async2`,然后将 await 后面的代码也就是 `console.log(async1 end)`加入到microtask 中的 Promise 队列中，接着跳出 async1 函数来执行后面的代码。

5. script 任务继续往下执行，遇到了 Promise 实例。由于 Promise 中的函数是立即执行的，而后续的 `.then` 则会被分发到 microtask 中的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 promise2 分配到对应队列。

6. script 任务继续往下，最后输出了 `script end`，至此全局任务就执行完毕了。

7. 执行完一个宏任务后，回去检查是否存在微任务。如果有，则执行微任务直至清空 Microtask queue。所以在 script 任务执行完毕后，开始查找清空微任务队列。此时，微任务中 Promise 队列有两个任务 async1 end 和 promise2，因此按照先后顺序输出`async1 end` 和 `promise2`。当所有 Microtasks 执行完毕后，表示第一轮的循环就结束了。

8. 第二轮循环依旧从宏任务队列开始。此时宏任务重只有一个 setTimeout，取出直接输出即可，至此整个流程结束。

## 白屏时间和首屏时间

* **白屏时间 (White Screen Time)**

  * 定义：指用户打开网页后，在内容渲染出来之前看到的“空白屏幕”时间。也就是说，白屏时间是指页面开始加载到显示出任何可视内容之前的这段时间。
  * 衡量指标：白屏时间通常通过 First Paint (FP) 和 First Contentful Paint (FCP) 来衡量。

* **首屏时间 (First Screen Time)**

  * 定义：指用户访问网页后，浏览器渲染并显示出用户能够看到的第一屏内容的时间。首屏通常指页面中显示的第一部分，通常包括顶部的文字、图像、导航栏等，用户无需滚动就能看到的部分。
  * 衡量指标：首屏时间常通过 First Contentful Paint (FCP) 或 Largest Contentful Paint (LCP) 来衡量。

白屏时间和首屏时间通常会通过以下几个指标来衡量：

* **DNS 解析时间（ DNS Lookup Time ）**

  用户请求网页时，浏览器首先需要解析域名为 IP 地址，这个过程的耗时也会影响白屏时间。如果 DNS 解析时间较长，页面加载的初期就可能出现延迟。

* **TCP 连接时间（ TCP Connect Time ）**

  这是浏览器与服务器建立 TCP 连接所需的时间。在这段时间内，页面仍然是空白的。

* **DOMContentLoaded 时间**

  DOMContentLoaded 是一个事件，它指示 HTML 文档已完全加载和解析，但样式表、图片等资源可能还在加载中。这个时间点通常标志着页面的核心内容已加载完毕，是衡量白屏时间的重要指标。

* **First Paint（ FP ）**

  First Paint 指的是浏览器首次渲染任何像素的时间。它代表浏览器开始绘制页面的时间点，通常会看到背景色、占位图等内容的呈现。FP越早，白屏时间越短。

* **First Contentful Paint（ FCP ）**

  FCP 是指浏览器首次渲染出文本、图像或其他内容的时间。它是在用户看到页面的第一个可视内容时触发的事件，通常比 DOMContentLoaded 更接近用户看到实际内容的时间。FCP 是衡量白屏时间的一个重要指标。

* **Largest Contentful Paint（ LCP ）**

  LCP 主要衡量加载过程中，页面中最大可见元素（通常是图片、视频或大文本）的渲染时间。LCP 是衡量页面加载性能的重要指标，它代表用户认为页面加载完成的时间点。

* **Time to Interactive（TTI）**

  TTI 表示页面成为完全可交互的时间。即，所有资源加载完毕，事件处理器已经准备好，用户可以开始与页面进行交互。TTI 也是衡量白屏时间的一个重要指标。

* **Total Blocking Time（TBT）**

  TBT 衡量的是页面加载过程中，长时间阻塞主线程的时间。阻塞主线程的任务会导致用户无法与页面交互，因此 TBT 较长时，白屏时间可能会较长。
