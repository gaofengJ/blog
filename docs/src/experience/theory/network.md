---
title: 网络协议
description: 网络协议
---

# 网络协议面试题

## TCP中三次握手和四次挥手

### TCP 三次握手

TCP 协议中三次握手用于建立一个可靠的连接。具体步骤如下：

1. **SYN**：客户端向服务端发送一个 SYN（同步序列编号）包，表示客户端希望建立连接，并告知服务端初始序列号（Sequence Number）。

2. **SYN-ACK**：服务器收到 SYN 包后，响应一个包含 SYN 和 ACK（确认）标志的包，表示同意建立连接，并向客户端发送服务器的初始序列号。

3. **ACK**：客户端收到 SYN-ACK 包后，发送一个 ACK 包，确认已收到服务器的 SYN包。此时，三次握手完成，连接建立。

在三次握手中，序列号的使用是为了确保每个数据包的唯一性和顺序性。

### TCP 四次挥手

TCP 四次挥手用于终止连接。具体步骤如下：

1. **FIN**：客户端发送一个 FIN（终止）包，表示它希望终止连接。

2. **ACK**：服务器收到 FIN 包后，发送一个 ACK包，确认已收到终止请求。

3. **FIN**：服务器也发送一个 FIN 包，表示它也希望终止连接。

4. **ACK**：客户端收到服务器的 FIN 包后，发送一个 ACK 包，确认已收到服务器的终止请求。此时，连接正式关闭。

## 讲一下 HTTP/2 的多路复用

在 HTTP/1 中，每次请求都会建立一次 HTTP 连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求中占用了相当长的时间，即使开启了 Keep-Alive，解决了多次连接的问题，但依然有两个效率上的问题：

* 第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件这三个步骤。我们假设这三步用时都是1s，那么a文件用时为3s，b文件传输完成用时为6s。

* 第二个：连接数过多。假设 Apache 设置了最大并发数为300。因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面的某个请求处理完成。

HTTP/2 的多路复用就是为了解决上述的两个性能问题。

在 HTTP/2 中有两个非常重要的概念，分别是帧（frame）和流（stream）。

帧代表着最小的数据单位，每个帧都会标识出该帧属于哪个流，留也就是多个帧组成的数据流。

多路复用，就是在一个 TCP 连接中可以存在多个流。也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中队头阻塞问题，极大的提高传输性能。

## 帧是如何标记属于哪个流的

在 HTTP/2 中，每个帧都会有一个包含流标识符的字段，用于标记该帧属于哪个流。这些帧在同一个连接中传输，并通过流标识符区分它们的归属。具体来说，每个帧头部包含一个 31 位的流标识符字段，该字段标识了该帧所属的流。流标识符为 0 的帧是保留给特定用途的控制帧。

## 如果A 与 B 建立了正常连接后，从未相互发过数据，这个时候 B 突然机器重启，问 A 此时处于 TCP 什么状态？如何消除服务器程序中的这个状态？

在A和B建立正常连接后，如果B突然重启而从未相互传输数据，此时A的TCP连接状态会保持不变，处于`ESTABLISHED`状态。A的操作系统不会立即知道B已经重启，因为没有任何数据传输来触发连接状态的改变。通常，A需要通过发送或接收数据来检测到连接异常。

为了消除服务器程序中的这种状态，可以采取以下方法：

* 设置`SO_KEEPALIVE`选项：通过setsockopt函数开启TCP连接的Keep-Alive功能，这样可以定期发送Keep-Alive探测包来检测对方是否仍然在线。不过默认的Keep-Alive时间间隔可能较长，可以根据需要调整。

* 使用非阻塞模式和`select()`函数：将socket设置为非阻塞模式，并使用select()或poll()来监控socket的可读性或可写性，可以设定超时时间来避免长时间等待。

* 检测发送错误：当对端重启时，发送数据通常会导致发送错误，应用程序可以根据发送操作的返回值来判断并处理连接断开。

当看到连接状态为`ESTABLISHED`，开发者可以确信两端已经建立了可靠的连接，并可以开始数据传输。

## 介绍 HTTPS 握手过程

1. 客户端使用https的url访问web服务器,要求与服务器建立ssl连接
2. web服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端
3. 客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥
4. 客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥
5. 之后服务器与客户端使用秘钥加密传输

至此整个握手阶段结束。接下来，客户端与服务器进入加密通信。

## HTTPS 握手过程中，客户端如何验证证书的合法性

* **接收证书**：当客户端向服务器发起 HTTPS 连接时，服务器会发送其数字证书。这个证书包含服务器的公钥以及由认证机构（CA）签名的数字签名。

* **验证签名**：客户端检查证书的签名是否由其信任的 CA 签发。每个浏览器都有一个预装的受信任 CA 列表。客户端使用 CA 的公钥解密证书的签名，并与证书内容进行比较，确保签名有效。如果签名无效，则表示证书可能被篡改，连接会被中断​。

* **检查证书链**：客户端会从服务器证书开始，一直追溯到根证书，确保每个中间证书都是由上一级 CA 签发的，直到找到受信任的根证书。这就是所谓的“信任链”验证。如果信任链中任何一个证书无效，整个验证过程都会失败。

* **验证其他信息**：客户端还会检查证书的有效期，确保证书在当前日期内有效。同时，客户端会验证证书中的域名与用户请求的域名匹配。如果域名不匹配，验证也会失败。

* **处理自签名证书**：如果服务器使用的是自签名证书，客户端通常会发出警告，提示用户手动决定是否信任该证书。这种情况下，用户需要验证证书指纹，以确保证书不是中间人攻击的结果。

## HTTP状态码

HTTP状态码是一组标准化的代码，用于描述HTTP请求的结果。它们被分为五类，每一类都表示一类特定的响应：

* 1xx (信息响应)：表示请求已被接收，继续处理。

  * 100 Continue：客户端应该继续发送请求的剩余部分。

* 2xx (成功响应)：表示请求已成功接收、理解并被处理。

  * 200 OK：请求成功，服务器返回请求的资源。
  * 204 No Content：请求成功，但没有返回任何内容。

* 3xx (重定向响应)：表示请求需要进一步操作才能完成。

  * 301 Moved Permanently：请求的资源已被永久移动到新位置。
  * 302 Found：请求的资源临时位于不同位置。

* 4xx (客户端错误响应)：表示请求包含错误或无法被服务器处理。

  * 400 Bad Request：请求有语法错误或无效参数。
  * 401 Unauthorized：请求未授权，需要身份验证。
  * 403 Forbidden：服务器理解请求但拒绝执行。
  * 404 Not Found：请求的资源在服务器上未找到。

* 5xx (服务器错误响应)：表示服务器未能执行有效请求。

  * 500 Internal Server Error：服务器遇到错误，无法完成请求。
  * 502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效响应。
  * 503 Service Unavailable：服务器暂时无法处理请求，通常由于超载或维护。
  * 504 Gateway Timeout：网关超时。当一个服务器（通常是代理或网关）在作为中间层时，等待上游服务器（如数据库服务器、API 服务器）响应请求时发生超时，这时会返回 504 错误。

## GET和POST区别

* 语义和用途：

  * GET 请求用于从服务器获取资源或数据。它是一种“安全”的方法，不会对服务器上的数据造成任何改变。
  * POST 请求用于向服务器发送数据以进行处理，通常会引起服务器上数据的更改。例如，提交表单、上传文件等操作都是通过 POST 请求完成的。

* 参数传递方式：

  * 在 GET 请求中，参数会附加在 URL 的末尾，这意味着 URL 有长度限制，且参数在浏览器的地址栏中可见。
  * POST 请求则通过请求体传递数据，不受 URL 长度限制，且参数对用户不可见，更适合传递敏感信息。

* 缓存和书签：

  * GET 请求的结果通常是可以缓存的，并且可以被书签保存。当多次发送相同的 GET 请求时，理论上会返回相同的结果（即幂等性）。
  * POST 请求通常不会被缓存，且不能作为书签保存。因为 POST 请求可能会对数据进行修改，因此每次请求的结果可能不同。

* 幂等性：

  * GET 请求是幂等的，即多次执行相同的 GET 请求不会对服务器上的资源产生副作用。
  * POST 请求则不具备幂等性，多次执行可能会导致服务器上的资源发生多次变化。

* 安全性：

  * 虽然 POST 请求相比 GET 更适合传递敏感数据，但这并不意味着它更安全。实际上，无论是 GET 还是 POST，数据都可以被拦截或篡改，因此对于敏感信息传输，需要使用 HTTPS 协议来确保安全。
