---
title: JavaScript
description: JavaScript
---

# JavaScript 面试题

## `['1', '2', '3'].map(parseInt)`的输出值是什么？

输出结果为：`[1, NaN, NaN]`。

**原因：**

回调函数 parseInt 接收两个参数：要解析的字符和基数（进制）。

map 传递给 parseInt 的参数包括当前元素的值，当前元素的索引和数组本身。

* 第一次调用：`parseInt('1', 0, arr)` 会将字符串 '1' 解析为整数 1（在 radix 为 undefined 或者 radix 为 0 且 字符串不是以 '0x' 或者 '0X' 开头的情况下，基数为 10）

* 第二次调用：`parseInt('1', 1, arr)` 中基数 1 是无效的，因为基数应该在 2~36之间，所以返回 NaN

* 第三次调用：`parseInt('1', 2, arr)` 中基数 2 也是无效的，同样返回 NaN

**扩展：**

* `['10','10','10','10','10'].map(parseInt)` 返回值为 `[10, NaN, 2, 3, 4]`

* `parseInt('10', 2)` 中的基数为 2 的解释：
在这种情况下，字符串 '10' 是一个有效的二进制数。在二进制中，10 表示十进制中的数字 2。因此，parseInt('10', 2) 会成功地将二进制字符串 '10' 解析为整数 2。

## 防抖和节流的区别？如何实现？

防抖（Debounce）和节流（Throttle）是用来控制函数调用频率的两种常见技术，特别在处理频繁触发的事件（比如滚动、resize、输入框输入等）时很有用。

* 防抖（Debounce）：

  * 当事件触发后，等待一定的时间间隔，如果在这个时间间隔内再次触发了相同事件，则重新计时。直到事件触发的间隔超过设定的时间间隔后，才真正执行该事件的处理函数。

  * **适合场景**：如搜索框输入联想，用户输入停顿后再进行搜索

* 节流（Throttle）：

  * 当事件触发后，首先执行事件处理函数，然后在指定的时间间隔内不响应新的事件触发。只有间隔超过设定的时间间隔后，才会再次触发执行事件处理函数。

  * **适合场景**：如页面滚动事件，控制一定时间内只触发一次加载数据的操作

* 区别：

  * **执行时间点不同**：防抖是在事件停止触发后等待一段时间后执行最后一次触发的事件处理函数；节流是在指定时间间隔内执行事件处理函数，并且该时间间隔内不响应新的事件触发。

  * 适用场景不同：防抖适合减少频繁事件的触发，如输入框搜索建议；节流适合控制事件的频率，如滚动事件加载数据。


