---
title: JavaScript
description: JavaScript
---

# JavaScript 面试题

## `['1', '2', '3'].map(parseInt)`的输出值是什么？

输出结果为：`[1, NaN, NaN]`。

**原因：**

回调函数 parseInt 接收两个参数：要解析的字符和基数（进制）。

map 传递给 parseInt 的参数包括当前元素的值，当前元素的索引和数组本身。

* 第一次调用：`parseInt('1', 0, arr)` 会将字符串 '1' 解析为整数 1（在 radix 为 undefined 或者 radix 为 0 且 字符串不是以 '0x' 或者 '0X' 开头的情况下，基数为 10）

* 第二次调用：`parseInt('1', 1, arr)` 中基数 1 是无效的，因为基数应该在 2~36之间，所以返回 NaN

* 第三次调用：`parseInt('1', 2, arr)` 中基数 2 也是无效的，同样返回 NaN

**扩展：**

* `['10','10','10','10','10'].map(parseInt)` 返回值为 `[10, NaN, 2, 3, 4]`

* `parseInt('10', 2)` 中的基数为 2 的解释：
在这种情况下，字符串 '10' 是一个有效的二进制数。在二进制中，10 表示十进制中的数字 2。因此，parseInt('10', 2) 会成功地将二进制字符串 '10' 解析为整数 2。

## 防抖和节流的区别？如何实现？

防抖（Debounce）和节流（Throttle）是用来控制函数调用频率的两种常见技术，特别在处理频繁触发的事件（比如滚动、resize、输入框输入等）时很有用。

* 防抖（Debounce）：

  * 当事件触发后，等待一定的时间间隔，如果在这个时间间隔内再次触发了相同事件，则重新计时。直到事件触发的间隔超过设定的时间间隔后，才真正执行该事件的处理函数。

  * **适合场景**：如搜索框输入联想，用户输入停顿后再进行搜索

* 节流（Throttle）：

  * 当事件触发后，首先执行事件处理函数，然后在指定的时间间隔内不响应新的事件触发。只有间隔超过设定的时间间隔后，才会再次触发执行事件处理函数。

  * **适合场景**：如页面滚动事件，控制一定时间内只触发一次加载数据的操作

* 区别：

  * **执行时间点不同**：防抖是在事件停止触发后等待一段时间后执行最后一次触发的事件处理函数；节流是在指定时间间隔内执行事件处理函数，并且该时间间隔内不响应新的事件触发。

  * 适用场景不同：防抖适合减少频繁事件的触发，如输入框搜索建议；节流适合控制事件的频率，如滚动事件加载数据。

## Set、Map、WeakSet 和 WeakMap 的区别

* Set

存储唯一值的集合，无重复元素。
可以包含任何类型的值，无论是原始值还是对象引用。
方法包括 `add(value)、delete(value)、has(value)、clear() 和 size`。

* WeakSet:

存储对象引用的集合，不能包含原始值（例如 `int、boolean、string`）。
对象引用是弱引用，即如果没有其他引用指向该对象，则对象可以被垃圾回收。
没有 `clear()` 方法，也没有 `size` 属性，因为对象可能随时被回收。

* Map:

存储键值对的集合，键和值可以是任何类型。
保持键的插入顺序。
方法包括 `set(key, value)、get(key)、delete(key)、has(key) 和 size`。

* WeakMap:

类似于 Map，但键必须是对象，而不是原始值。
键是弱引用，如果没有其他引用指向该对象，则键和值可以被垃圾回收。
没有 `clear()` 方法，也没有 `size` 属性，因为键值对可能随时被回收。

## 介绍下深度优先遍历和广度优先遍历

* 深度优先遍历（DFS）

DFS是一种优先访问尽可能深的节点的遍历方法。其思想是从起始节点开始，沿着一条路径一直走到底，然后回溯到上一个节点，再探索其他路径，直到所有节点都被访问过。

* 广度优先遍历（BFS）

BFS是一种优先访问距离起始节点最近的节点的遍历方法。其思想是从起始节点开始，逐层访问其邻近节点，再访问这些邻近节点的邻近节点，直到所有节点都被访问过。
