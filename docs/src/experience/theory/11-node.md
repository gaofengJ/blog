---
title: Node
description: Node
---

# Node 面试题

## Nodejs 适用场景

* 业务开发

* BFF 开发（`Backend for Frontend`）。BFF 的核心思想是为不同类型的前端（如 Web 应用、移动应用、小程序等）提供特定的后端服务，解决前端开发中通用后端接口难以满足不同前端需求的问题。

* 前端基建，SSR/构建工具等

## 浏览器和 Node 事件循环的区别 <span style="padding: 2px 8px; background: #EC5975; color: #FFF; border-radius: 4px;">高频</span>

* **浏览器**

  关于微任务和宏任务在浏览器的执行顺序是这样的：

  * 执行一个macro-task（宏任务）
  * 执行完micro-task队列（微任务）

* **Node**

  Node的事件循环是libuv实现的。

  大体的task（宏任务）执行顺序是这样的：

    1. Timers 阶段：执行 setTimeout 和 setInterval 的回调函数。
    2. I/O 回调阶段：执行 I/O 相关的回调函数。
    3. Idle, Prepare 阶段：系统内部使用，几乎没有用户代码。
    4. Poll 阶段：执行新的 I/O 事件，或等待新的 I/O。
    5. Check 阶段：执行 setImmediate 的回调。
    6. Close 阶段：执行关闭事件的回调，比如 socket.on('close')。

  Node 10 以前：

  * 执行完一个阶段的所有任务
    * 在每个事件循环阶段（如 Timers 阶段、Poll 阶段等），会先执行该阶段的所有回调函数。
  * 执行完 nextTick 队列里面的内容
    * 在当前阶段的任务全部完成后，先清空 process.nextTick 队列。
    * 这会在任何微任务队列之前执行。
  * 然后执行完微任务队列的内容
    * 在清空 process.nextTick 队列后，执行微任务队列中的所有任务（比如 Promise 的 .then 回调）

  Node 11 以后和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列。

# Buffer怎么理解，有什么应用

在 Node.js 中，Buffer 是一种专门处理二进制数据的对象。它非常有用，因为 JavaScript 本身在处理二进制数据方面的支持有限。Buffer 允许你直接操作内存并以字节为单位操作数据，因此在处理文件、网络数据流和其他低级别的任务时非常重要。

**应用场景**

* **文件读写**
  
    当你需要读取或写入文件时，Buffer 能够高效处理二进制内容。
* **网络数据传输**
  
    处理 TCP/UDP 套接字时，数据通常以二进制形式接收，Buffer 是处理这些数据的核心工具。
* **数据编码和解码**
  
    Buffer 可以用于将数据编码为不同格式（如 Base64、Hex）或从这些格式解码。
* **数据分块处理**
  
    在处理流时，Buffer 用来缓存分块的数据，直到它们可以作为一个整体进行处理。

```js
const str = 'Hello World';
const buf = Buffer.from(str, 'utf-8');
const hex = buf.toString('hex');
console.log(hex); // 输出：48656c6c6f20576f726c64

```

## 什么是I/O

I/O 指的是计算机的输入/输出操作，是系统与外部环境（如用户或其他设备）交互的基本方式。在编程和计算机科学中，I/O 通常涉及文件读写、网络通信、或与硬件设备交互。

## 常见的 Nodejs 框架

* **Express.js**

  * **特点**：轻量级且高度灵活，是 Node.js 生态中最受欢迎的框架之一。支持中间件，拥有庞大的插件生态。
  * **适用场景**：适用于快速构建简单的 Web 应用和 RESTful API。
优缺点：简单易用，适合初学者，但大型项目可能需要额外的架构设计。

* **NestJS**

  * **特点**：基于 TypeScript 的渐进式框架，借鉴了 Angular 的设计理念，提供模块化和依赖注入。
  * **适用场景**：适合大型、结构化的企业级应用。
优缺点：学习曲线稍高，但提供了强大的类型安全和结构化代码支持。

* **Koa.js**

  * **特点**：由 Express 的原班团队开发，使用现代化的中间件结构（基于 async/await），避免了回调地狱。
  * **适用场景**：适合需要高性能和更灵活控制的应用。
优缺点：核心库很小且简洁，但需要手动选择中间件。

* **Eggjs**
  * **特点**：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件
  * **适用场景**：适合企业级复杂应用、后端服务和多场景应用，比如 RESTful API 和电商平台。

## Node中间件作用 <span style="padding: 2px 8px; background: #EC5975; color: #FFF; border-radius: 4px;">高频</span>

在 Node.js 的不同框架中，中间件的原理基本上是相同的，虽然框架的实现方式和 API 可能有所不同，但核心思想是一样的。以下是 Node.js 中间件的基本原理：

**中间件的原理**：

* **请求-响应周期**

中间件通常处于请求和响应的生命周期中。在一个 HTTP 请求从客户端发送到服务器并返回响应的过程中，每一个中间件函数都会依次处理请求和/或响应。

在请求流中，中间件可以执行以下操作：

* 修改请求对象（req）。
* 修改响应对象（res）。
* 终止请求-响应周期，直接发送响应。
* 调用 next() 函数将控制权传递给下一个中间件。

* **串联执行**：

中间件是按顺序执行的，每个中间件处理完后，可以通过 next() 函数将控制权传递给下一个中间件，或者通过直接发送响应结束请求周期。

* **顺序控制**：

框架会将所有中间件按顺序链式调用。在 Express、Koa、Egg.js 等框架中，开发者可以自由地定义中间件的顺序，因为中间件的执行顺序是很重要的。一般来说，错误处理和响应生成的中间件应该放在最后，身份验证等操作应放在前面。

**中间件工作流**：

假设请求依次进入一系列中间件，它们的工作流如下：

* **请求进入第一个中间件**：处理请求，可能修改 req 对象，然后调用 next() 或直接发送响应。
* **进入下一个中间件**：接收上一个中间件的修改，继续处理逻辑。
* **直到请求结束**：要么响应被发送，要么最后的中间件将控制权交回框架，默认处理响应。

**框架实现的差异**：

尽管大多数框架的中间件原理相同，但每个框架在实现时可能会有所不同：

* Express：使用 app.use() 来注册中间件。中间件函数接受三个参数：req、res 和 next()，它是最简单的实现。
* Koa：是基于 async/await 的，它使用 app.use() 注册中间件，但中间件函数是 async 函数，需要 await next() 来实现传递控制。
* Egg.js：在 Koa 的基础上构建，添加了更多企业级功能，插件机制是其中间件系统的一个亮点。

## 为什么要有中间件 <span style="padding: 2px 8px; background: #EC5975; color: #FFF; border-radius: 4px;">高频</span>

* 请求处理的模块化

  中间件允许开发者将请求处理过程分解成多个小的、可重用的逻辑单元。开发者不需要将所有逻辑都写在路由处理程序中，而是可以使用中间件对请求进行不同阶段的处理。这样的模块化使得应用更加清晰、易于维护和组织。

* 函数链式执行

  Express 中的中间件函数按顺序执行。每个中间件可以修改请求（req）和响应（res）对象，或者通过调用 next() 将控制权传递给下一个中间件函数。这种链式机制确保请求在最终的处理程序或响应阶段之前能够进行多次修改。例如，可以通过中间件进行认证、日志记录、数据验证或错误处理

* 关注点分离

  中间件帮助将应用中的不同关注点分离开。你可以将复杂的逻辑从路由处理程序中提取出来，单独放入中间件中处理。这不仅提升了代码的可读性和可维护性，还减少了代码的重复，增强了应用的扩展性

* 灵活的执行方式

  中间件可以全局应用（如使用 app.use()），也可以针对特定路由进行应用，允许开发者精确控制在何时何地执行特定的逻辑。这种灵活性非常适合进行如认证检查、启用不同的行为或优化性能等任务

## 洋葱模型

洋葱模型（Onion Model） 是 Koa 和其他一些 Web 框架中常用的中间件执行模型。它的核心概念是中间件按照“洋葱”形状执行，每个中间件都可以同时进行请求处理和响应处理。这种结构意味着请求会先经过外层中间件，进入内部中间件处理，然后在响应阶段按相反顺序返回外层中间件进行处理。

与传统的中间件模型（如 Express 的线性执行）不同，洋葱模型使得前置和后置处理逻辑更容易管理，特别适用于复杂的请求处理场景

## 什么是Stream流，有哪些应用场景

Stream（流）是指一系列按顺序处理的数据。与一次性加载所有数据的传统方式不同，Stream 允许数据分段、分批次处理，通常是在数据逐步到达时进行处理，避免了内存过载的问题。Stream 在 Node.js 中尤为常见，主要通过 Readable, Writable 和 Duplex 等流接口来实现。

**Stream 的应用场景**：

* **处理大文件**

  例如，在处理大文件时，可以使用流逐步读取和处理文件内容，而不需要一次性将整个文件加载到内存中，这样可以大大减少内存的消耗。

* **网络传输**

  例如，进行大规模的数据传输时，Stream 可以通过管道传输数据，实现边传输边处理，避免了阻塞和过多的数据积压。

* **音视频流**

  例如，在视频流的处理过程中，可以逐步加载视频文件并进行播放，而不需要等待整个文件下载完毕。

* **日志处理**

  对于实时日志数据，可以使用 Stream 持续读取日志并进行处理，避免一次性加载所有日志数据导致内存压力过大。

## 什么是 ORM

ORM 是一种通过将对象数据模型和关系数据库之间的映射进行管理，来简化数据库操作的技术。通过ORM，开发者可以直接在代码中操作对象，不需要手动编写SQL查询语句。ORM框架提供的功能包括自动映射数据库表字段与对象属性，支持CRUD（增删改查）操作，以及事务管理等。

## 什么是 Redis

Redis 是一个开源的内存数据结构存储系统，它通常被用作数据库、缓存和消息代理。它支持多种数据结构，包括字符串、哈希、列表、集合、有序集合等，可以为应用程序提供高效的数据存储和访问。

**Redis 的主要特点包括**：

* **内存存储**

  数据主要存储在内存中，这使得其访问速度非常快。

* **持久化选项**

  Redis 提供多种持久化机制，如 RDB（Redis 数据库备份）和 AOF（追加文件日志），可以保证在重启或故障恢复时数据不丢失。

* **高性能**

  由于其数据存储在内存中，Redis 提供了非常高的读写速度，适合需要低延迟的数据处理场景。

* **支持多种数据结构**

  除了传统的键值对，Redis 还支持如列表、集合、哈希等更复杂的数据结构。

## 常见的数据库优化

常见的数据库优化方案包括以下几个方面：

* **索引优化**

  创建和优化索引是提高数据库查询性能的常见方法。合适的索引能够加速数据检索，避免全表扫描。特别是在复杂查询中，复合索引（涉及多个列的索引）可以极大提高查询效率​。

* **查询优化**

  避免使用低效的查询语句，例如 SELECT *，尽量避免对大表进行全表扫描，使用 EXPLAIN 等工具来分析查询计划并优化查询​。

* **缓存策略**

  使用缓存来存储常查询的数据，减少数据库负担。常用的缓存系统包括 Redis 和 Memcached​。

* **分区和分表**

  对于数据量巨大的表，考虑使用分区或分表来将数据分散到多个物理文件中，从而减少查询时的读取范围​。

* **数据库的正常化与反向规范化**

  根据需求在不同的应用场景下，合理进行数据库表的规范化（减少冗余数据）和反向规范化（为提高查询性能而增加冗余字段）​。

* **连接池优化**

  合理配置数据库连接池，避免每次请求都建立新的数据库连接。连接池可以复用连接，减少连接建立和销毁的开销​。

* **定期维护**

  定期进行数据库的碎片整理、统计信息更新等维护操作，以保证数据库的最佳性能​

## 什么是 NestJS，他的核心特征是什么？

`NestJS` 是一个基于 `TypeScript` 构建的渐进式框架，用于构建高效且可扩展的服务器端应用程序。它以 **模块化架构** 和 **依赖注入（DI）** 为核心

## NestJS 中的模块是什么？如何定义一个模块？

NestJS 中的模块是用于组织和管理应用程序功能的基本构建块。每个模块都是一个类，并使用 @Module() 装饰器进行装饰。

## 什么是依赖注入？在 NestJS 中如何实现？

依赖注入（Dependency Injection, DI）是一种设计模式，用于将对象的依赖项从代码中分离，并通过外部注入方式提供依赖。

在 NestJS 中，通过 服务（Service） 和 装饰器 实现依赖注入：

* 使用 @Injectable() 装饰器定义一个服务。
* 在其他类中通过构造函数注入服务。

```js
@Injectable()
export class UserService {
  getUser() {
    return 'User Info';
  }
}

@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Get()
  getUser() {
    return this.userService.getUser();
  }
}

```

## 装饰器是什么？如何实现一个简单的装饰器？

装饰器 是一种特殊的语法，允许在类、方法、属性或参数上添加元数据或逻辑，从而扩展或修改其行为。它本质上是一个 **函数**，可以通过 @ 语法应用于目标。

根据作用对象的不同，装饰器可以分为以下几类：

* 类装饰器：应用于类本身。
* 方法装饰器：应用于类的方法。
* 属性装饰器：应用于类的属性。
* 参数装饰器：应用于类方法的参数。

举例：

```js
function Logger(target: Function) {
  console.log('Logging class:', target.name);
}

@Logger
class UserService {
  getUser() {
    return 'User data';
  }
}

Logging class: UserService

```
