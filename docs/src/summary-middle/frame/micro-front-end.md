---
title: 微前端
description: 框架
---

转载自[https://wujie-micro.github.io/doc/guide/](https://wujie-micro.github.io/doc/guide/)。

# 微前端

## 微前端是什么？

微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。

通俗来说，就是在一个web应用中可以独立的运行另一个web应用。

## 微前端应用场景

* 比如制作一个企业管理平台，把已有的采购系统和财务系统统一接入这个平台

* 比如有一个巨大的应用，为了降低开发和维护成本，分拆成多个小应用进行开发和部署，然后用一个平台将这些小应用集成起来

* 又比如一个应用使用 vue 框架开发，其中有一个比较独立的模块，开发者想尝试使用 react 框架来开发，等模块单独开发部署完，再把这个模块应用接回去

## 微前端应该有哪些能力

* 子应用的加载和卸载能力

  页面需要从一个子应用切换到另一个子应用，框架必须具备加载、渲染、切换的能力

* 子应用独立运行的能力

  子应用运行会污染全局的 window 对象，样式会污染其他应用，必须有效的隔离起来

* 子应用路由状态保持能力

  激活子应用后，浏览器刷新、前进、后退子应用的路由都应该可以正常工作

* 应用间通信的能力

  应用间可以方便、快捷的通信

## 微前端优势

* 技术栈无关

  主框架不限制接入应用的技术栈，微应用具备完全自主权

* 独立开发、独立部署

  微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新

* 增量升级

  在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略

* 独立运行时

  每个微应用之间状态隔离，运行时状态不共享

## 微前端方案

### iframe 方案

* 优点
  * 非常简单，使用没有任何心智负担
  * web 应用隔离非常完美，无论是 js、css、css、dom 都可以完全隔离开

* 缺点
  * 路由状态丢失，刷新一下，iframe 的 url 状态就丢失了
  * dom 割裂严重，弹窗只能在 iframe 内部展示，无法覆盖全局
  * web 应用之间通信非常困难
  * 每次打开白屏时间太长，对于 SPA 应用来说无法接受

> [!TIP]
>
> * 基于 iframe 的微前端方案在每次打开时出现白屏时间较长的原因主要有以下几点：
>   * 完整加载: 每个 iframe 都是一个独立的文档，需要单独加载所有资源（HTML、CSS、JavaScript 等），这可能导致加载时间较长，尤其是在网络条件不佳时。
>   * 资源重复: 如果多个子应用使用相同的资源（如库文件），每个 iframe 会各自加载这些资源，增加了请求数量和加载时间。
>   * DOM 渲染: iframe 内部的 DOM 渲染需要时间，特别是子应用复杂时，可能导致明显的加载延迟。
>   * 跨域问题: 如果子应用部署在不同的域，浏览器可能会对跨域资源加载进行限制或延迟，进一步增加加载时间。
>   * 性能优化不足: 一些子应用可能没有进行必要的性能优化，如资源压缩、懒加载等，导致整体加载速度慢。
>   * 初始化过程: 子应用在加载后，可能需要进行一些初始化操作（如状态管理、API 调用等），这一过程也可能导致白屏时间延长。
> * 为了减少白屏时间，可以考虑以下优化策略：
>   * 共享依赖库，避免重复加载。
>   * 使用预加载和懒加载技术。
>   * 优化资源大小，进行压缩和合并。
>   * 提前渲染和缓存策略，以提高加载效率。

### single-spa 方案

[single-spa](https://zh-hans.single-spa.js.org/docs/getting-started-overview/)是一个目前主流的微前端技术方案，其主要实现思路：

* 预先注册子应用(激活路由、子应用资源、生命周期函数)
* 监听路由的变化，匹配到了激活的路由则加载子应用资源，顺序调用生命周期函数并最终渲染到容器

[乾坤](https://qiankun.umijs.org/zh/guide)微前端架构则进一步对 `single-spa` 方案进行完善，主要的完善点：

* 子应用资源由 js 列表修改进为一个 url，大大减轻注册子应用的复杂度
* 实现应用隔离，完成 js 隔离方案（window 工厂） 和 css 隔离方案 （类 vue 的 scoped）
* 增加资源预加载能力，预先子应用 html、js、css 资源缓存下来，加快子应用的打开速度

* 优点
  * 监听路由自动的加载、卸载当前路由对应的子应用
  * 完备的沙箱方案，js 沙箱做了 `SnapshotSandbox`、`LegacySandbox`、`ProxySandbox` 三套渐进增强方案，css 沙箱做了两套 `strictStyleIsolation`、`experimentalStyleIsolation` 两套适用不同场景的方案
  * 路由保持，浏览器刷新、前进、后退，都可以作用到子应用
  * 应用间通信简单，全局注入

* 缺点
  * 基于路由匹配，无法同时激活多个子应用，也不支持子应用保活
  * 改造成本较大，从 webpack、代码、路由等等都要做一系列的适配
  * css 沙箱无法绝对的隔离，js 沙箱在某些场景下执行性能下降严重
  * 无法支持 vite 等 ESM 脚本运行

### 无界方案

**应用加载机制和 js 沙箱机制**

将子应用的 js 注入主应用同域的 iframe 中运行，iframe 是一个原生的 window 沙箱，内部有完整的 history 和location 接口，子应用实例 instance 运行在iframe中，路由也彻底和主应用解耦，可以直接在业务组件里面启动应用。

* 组件方式来使用微前端

  不用注册，不用改造路由，直接使用无界组件，化繁为简

* 一个页面可以同时激活多个子应用

  子应用采用 iframe 的路由，不用关心路由占用的问题

* 天然 js 沙箱，不会污染主应用环境

  不用修改主应用window任何属性，只在iframe内部进行修改

* 应用切换没有清理成本

  由于不污染主应用，子应用销毁也无需做任何清理工作

**路由同步机制**

在 iframe 内部进行 `history.pushState`，浏览器会自动的在 `joint session history` 中添加 iframe 的 `session-history`，浏览器的前进、后退在不做任何处理的情况就可以直接作用于子应用

劫持 `iframe` 的 `history.pushState` 和 `history.replaceState`，就可以将子应用的url同步到主应用的query参数上，当刷新浏览器初始化iframe时，读回子应用的url并使用iframe的history.replaceState进行同步

* 浏览器刷新、前进、后退都可以作用到子应用
* 实现成本低，无需复杂的监听来处理同步问题
* 多应用同时激活时也能保持路由同步

**iframe 连接机制和 css 沙箱机制**

无界采用 [webcomponent](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components) 来实现页面的样式隔离，无界会创建一个 `wujie` 自定义元素，然后将子应用的完整结构渲染在内部。

子应用的实例 `instance` 在 `iframe` 内运行，`dom` 在主应用容器下的 `webcomponent` 内，通过代理 `iframe` 的 `document` 到 `webcomponent`，可以实现两者的互联。

将 `document` 的查询类接口：`getElementsByTagName`、`getElementsByClassName`、`getElementsByName`、`getElementById`、`querySelector`、`querySelectorAll`、`head`、`body`全部代理到 `webcomponent`，这样 `instance` 和 `webcomponent` 就精准的链接起来。

当子应用发生切换，`iframe` 保留下来，子应用的容器可能销毁，但 `webcomponent` 依然可以选择保留，这样等应用切换回来将 `webcomponent` 再挂载回容器上，子应用可以获得类似 `vue` 的 `keep-alive` 的能力。

* 天然 css 沙箱

  直接物理隔离，样式隔离子应用不用做任何修改

* 天然适配弹窗问题

  `document.body` 的 `appendChild` 或者 `insertBefore` 会代理直接插入到 `webcomponent`，子应用不用做任何改造

* 子应用保活

  子应用保留 `iframe` 和 `webcomponent`，应用内部的 `state` 不会丢失

* 完整的 DOM 结构

  `webcomponent` 保留了子应用完整的 `html` 结构，样式和结构完全对应，子应用不用做任何修改

**通信机制**

承载子应用的 `iframe` 和主应用是同域的，所以主、子应用天然就可以很好的进行通信，在无界我们提供三种通信方式

* props 注入机制

  子应用通过 `$wujie.props`可以轻松拿到主应用注入的数据

* `window.parent` 通信机制

  子应用 `iframe` 沙箱和主应用同源，子应用可以直接通过 `window.parent` 和主应用通信

* 去中心化的通信机制

  无界提供了 `EventBus` 实例，注入到主应用和子应用，所有的应用可以去中心化的进行通信

**总结一下 wujie 的优势**

* 多应用同时激活在线

  框架具备同时激活多应用，并保持这些应用路由同步的能力

* 组件式的使用方式

  无需注册，更无需路由适配，在组件内使用，跟随组件装载、卸载

* 应用级别的 `keep-alive`

  子应用开启保活模式后，应用发生切换时整个子应用的状态可以保存下来不丢失，结合预执行模式可以获得类似 ssr 的打开体验

* 纯净无污染
  * 无界利用 `iframe` 和 `webcomponent` 来搭建天然的 js 隔离沙箱和 css 隔离沙箱
  * 利用 `iframe` 的 `history` 和主应用的 `history` 在同一个 `top-level browsing context` 来搭建天然的路由同步机制
  * 副作用局限在沙箱内部，子应用切换无需任何清理工作，没有额外的切换成本

* 性能和体积兼具

  * 子应用执行性能和原生一致，子应用实例 `instance` 运行在 `iframe` 的 `window` 上下文中，避免 `with(proxyWindow){code}` 这样指定代码执行上下文导致的性能下降，但是多了实例化 `iframe` 的一次性的开销，可以通过 `preload` 提前实例化
  * 体积比较轻量，借助 `iframe` 和 `webcomponent` 来实现沙箱，有效的减小了代码量

* 开箱即用

  不管是样式的兼容、路由的处理、弹窗的处理、热更新的加载，子应用完成接入即可开箱即用无需额外处理，应用接入成本也极低。
